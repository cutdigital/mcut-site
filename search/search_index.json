{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>What you can do with MCUT: A Max Planck model cuts a cube. </p> <p>MCUT (pronounced \u2018emcut\u2019) is a tool for cutting meshes: It is a library for partitioning surface-meshes using their geometry to produce crisp fragments at fine scale, which is useful for operations like slicing and boolean operations. Supported features include stencilling (exact cut-outs of the cutting surface), intersection-curve queries and partial cuts. MCUT is a tool providing a general solution to the problem of resolving mesh intersections.</p>"},{"location":"#design-principles","title":"Design principles","text":"<p>The design principles of MCUT are as follows:</p> <ul> <li> <p>Robust: Thorougly tested. </p> </li> <li> <p>Simple: Easy and portable API.</p> </li> <li> <p>Minimal: Self-contained.</p> </li> </ul> <p>An illustrative gist of what MCUT does: On the left is a cube (the \"source mesh\") that is cut by a circular surface (the \"cut mesh\"), which together comprise the input. On the right is the resulting set of connected components after partitioning the cube. In general, the output of MCUT includes unsealed fragments (mid-left), cut mesh patches (middle), and the sealed fragments whose holes have been filled with cut mesh polygons that lie on the interior of the source mesh. Sealing can also be done using cut mesh polygons that lie on the exterior of the source mesh. . </p>"},{"location":"#motivation","title":"Motivation","text":"<p>Mesh cutting is fundamental and useful for solving a wide set of problems. The goal is to split a given surface mesh into a set of disjoint parts using another surface mesh. These resulting parts are typically employed in model design and/or simulation, such as virtual surgery, game level-design, computer aided design and manufacturing.</p> <p>Despite existing tools (e.g. CGAL, Cork, EMBER, Carve, PWN or TetMesh tools), it remains a challenge to slice meshes without restrictive assumptions on the input. Moreover, besides traditional CSG operations, most sophisticated modelling software (e.g. Maya, Cinema4D, Blender, MeshMixer, ANSYS SpaceClaim etc.) allow users only to cut meshes with a plane which restricts modelling and design capabilities.</p>"},{"location":"#features","title":"Features","text":"<p>In addition to being simple and robust, MCUT is specifically designed to be a cutting tool which supports the following features: </p> <ul> <li>Manifold meshes: open  (with borders/boundaries), or closed (as in \u2018watertight\u2019 solids). </li> <li>Partial cuts: A sliced object need not be completely cut into disjoint parts. </li> <li>Stencilling: Silhouette cut-outs of the cutting surface patches.</li> <li>Intersection curves: Query vertices introduced as a result of a cut.</li> <li>Booleans: Traditional CSG operations. </li> <li>N-gons: Arbitrary planar-polygon meshes. </li> </ul> <p>An extreme example, which is a result of cutting a source mesh that has concave polygons. The source mesh was a pentagonal frustum with the pentagons (top and bottom faces) made concave (and not parallel to each other). Each pentagon was composed of polygons with several concavities. The whole model was composed of only one volume element (all edges are on the surface). MCUT produces the correct fragments, and does not modify the connectivity except where intersected with the cut mesh. </p>"},{"location":"#contact","title":"Contact","text":"<p>MCUT is an endeavor led by Floyd Chitalu via CutDigital Enterprise Ltd. Please write an email if you have questions or comments. For troubleshooting, please post an issue on github.</p>"},{"location":"bug-report/","title":"Bug report","text":"<p>Before asking about an issue, please check the following:</p> <p>Tip</p> <ul> <li> <p>Read the   FAQ before asking a new   question, search existing   issues   for a problem similar to yours.</p> </li> <li> <p>Check the tutorials.</p> </li> </ul> <p>General issues</p> <ul> <li> <p>Be up-to-date with the master branch, and ensure that   your issue has not already been fixed.</p> </li> <li> <p>To report a problem about the website (out-of-date content, erroneous instructions etc.), open an issue in the   designated repository for the website.</p> </li> </ul>"},{"location":"building/","title":"Compilation","text":"<p>MCUT is hosted on Github. </p> <p>System requirements</p> <ul> <li>CMake. </li> <li>C++11 compiler support. </li> </ul> <p>Setup</p> <pre><code>git clone https://github.com/cutdigital/mcut.git\ncd mcut/ \nmkdir build \ncd build \ncmake .. \n</code></pre> <p>Refer to the <code>mcut/CMakeLists.txt</code> for information about additional configuration flags.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#summary-table","title":"Summary Table","text":"Click to unroll. Version Short description master version 1.0.0 content 1.0.0 Major release: API, tutorials, MPFR support"},{"location":"changelog/#future-editions","title":"Future editions","text":"<ul> <li>Querying partially sealed fragments</li> <li>More tutorials</li> <li>Multi-threading<ul> <li>Events</li> </ul> </li> <li>Profiling<ul> <li>Timers</li> </ul> </li> <li>Propagating vertex attributes (UVs etc.)</li> </ul>"},{"location":"changelog/#upcoming-version-master-branch","title":"Upcoming version (<code>master</code> branch)","text":""},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Performance improvements</li> </ul>"},{"location":"changelog/#version-10-changes","title":"Version 1.0 Changes","text":"<p>Our first release marks our confidence that this library can be used outside of casual experimenting. </p> <ul> <li>Arbitrary manifold meshes. </li> <li>Partial cut intersections. </li> <li>Stencilling.</li> <li>Intersection path queries</li> <li>Booleans</li> <li>N-gons</li> </ul>"},{"location":"faq/","title":"FAQ","text":"Is MCUT restricted to triangle meshes? <p>No. MCUT is designed to work with meshes that are made with arbitrary simple polygons. These polygons can be convex or concave, so triangle meshes are just a special case.</p> Is it possible that MCUT can fail to fill holes in sliced objects? <p>MCUT can never fail to fill holes because the output meshes are produced by resolving/tracing the halfedge connectivity of input meshes. This is different from winding numbers and improves overall robustness since numerical operations are performed only when resolving polygon intersections. </p> Does MCUT do automatic triangulation after cutting e.g. for rendering? <p>Yes. MCUT also provides functionality to query the exact faces/polygons (which may be convex and/or concave) that are produced as a result of an intersection between two meshes.</p> Can MCUT cut more than two meshes at the same time? <p>MCUT is designed to work at-most with two meshes at a time. This simplifies reasoning about the implementation.</p> I wish to slice a tetrahedral/hexahedral mesh using MCUT - is this possible? <p>In general, no. This is because tetrahedral/hexahedral meshes are non-manifold, which is beyond the scope of MCUT.</p> <p>However, you may be able to use MCUT as a building block to cut individual cells (tetrahedra/hexahedra) of your mesh with the given cutting surface. This of course implies that you must then resolve the connectivity of your non-manifold mesh manually, effectively building on top of MCUT.</p> Can the cut surface be a non-manifold mesh? <p>No. The cut surface must always be a manifold surface mesh. </p> What constitues a valid mesh for MCUT? <p>A valid mesh is a connected component which is a manifold surface that has no self-intersections involving polygons along the cut (e.g. potentially intersecting polygons). We take the definition of manifold to be a mesh where every edge is incident to (i.e. used by) one or two faces.</p> Where can I find the documentation for using MCUT? <p>Function documentation is provided in the main header file, which is <code>include/mcut/mcut.h</code>. There are three options for viewing this documentation: 1) building the docs with doxygen (see Compilation), 2) doing a Ctrl+F on <code>mcut.h</code> in your favourite text editor/IDE, and 3) using the github search function in the MCUT repository.</p> <p>The tutorials are also useful.</p> What is a \u2018mesh\u2019? <p>A mesh is a data structure consisting of a set of input vertices, edges, faces and topological relations between them. This data structure defines how each element is stored.</p> What is a \u2018connected component\u2019? <p>A connected component is the general name given to a mesh. In particular, it has the property that for any two faces in this mesh, there is a path of adjacent faces such that all edges between two consecutive faces of the path are not marked as constrained.</p> What is a \u2018source mesh\u2019? <p>A source mesh is the input mesh you want to cut.</p> What is a \u2018cut mesh\u2019? <p>A cut mesh is the  input mesh you want to cut with (i.e. the knife tool).</p> What is a \u2018fragment\u2019? <p>A fragment is a connected component that resulted from partitioning the source mesh - sealed or unsealed.</p> What is a \u2018patch\u2019? <p>A patch is a connected component that is used to a seal hole in a fragment. It is a piece produced from the cut mesh.</p> What is a \u2018seam\u2019 connected component? <p>A connected component produced by MCUT which is same as an input mesh (source mesh or cut mesh) except that it has new edges which are placed according to the cut.  </p> What is the meaning of \u2018fragment location\u2019? <p>The relative location of a fragment with respect to the cut mesh, which is determined by the face orientation (winding order) of the cut mesh. </p> <p>Example: A tetrahedron (source mesh) that is sliced in the middle with a quad (cut mesh), where the apex lies in the normal direction of the quad. In this case, the apex fragment is considered \u2018above\u2019, while the 6 sided fragment is considered \u2018below\u2019.</p> What is the meaning of \u2018patch location\u2019? <p>The relative location of a patch with respect to the source mesh, which is determined by the face orientation (winding order) of the source mesh. Intuitively, the subset of cut mesh polygons\u2013after clipping\u2013that lie inside (say, a watertight) source mesh are considered \u2018inside\u2019, and those not as \u2018outside\u2019. </p> Must all input meshes have a consistent winding order? <p>Yes. All input meshes must have a consistent winding order, but this order can be either clock-wise (CW) or counter clock-wise (CCW). Note however, that the source mesh can be CCW while the cut mesh is CW, and vice-versa.</p> Degenerate inputs (not in general position) <p>MCUT expects that all polygon intersections can be reduced to edge-face intersections. </p> <p>Thus, MCUT is designed for inputs in \u201cgeneral position\u201d, but also provides a crude workaround for degenerate inputs. Here the notion of general position is defined with respect to the orientation predicate: a set of points is in general position if no three points (where two points are from the same input mesh) are collinear, or that no four points (where three points from the same input mesh) are coplanar.</p> <p>The definition of \u201cinputs\u201d is relaxed here: i.e. only considering the list of pairs of polygons from the source-mesh and cut-mesh that are tested for intersection. Thus, the polygons that are not intersecting in any form (i.e. even not touching) do not have to be in general position.</p> <p>MCUT will use numerical perturbation of the cut-mesh so as to bring the input into general position. In such cases, the idea is to solve the cutting problem not on the given input, but on a nearby input. The nearby input is obtained by perturbing the given input. The perturbed input will then be in general position and, since it is near the original input, the result for the perturbed input will hopefully still be useful. This is justified by the fact that the task of MCUT is not to decide whether the input is in general position but rather to make perturbation on the input (if) necessary within the available precision of the computing device. </p> <p>Perturbation is enabled by including the appropriate <code>MC_DISPATCH_ENFORCE_GENERAL_POSITION</code> flag when calling the <code>mcDispatch</code> function, which is the crude workaround for degenerate inputs.</p> <p>Note: MCUT does not use symbolic perturbation since correct labelling of polygon intersection points is dependent on orientation predicates giving true answer i.e. <code>orient3d</code> and <code>orient2d</code> must return one of three values {-1, 0, +1} and not two {-1 or +1}, which is the essence of symbolic perturbation. The reason for MCUT doing this is that it allows us to identify intersection points \u2018topologically\u2019 and ensure that the entire implementation is free of numerical operations, except when dealing with polygon intersection points. Under the assumption of general position, intersection points can be uniquely identified according to the faces (from the source mesh and cut-mesh) that meet there, as well as the (half)edge that intersected a face to yeild that point.</p> <p>A key objective in the design of MCUT is to resolve the combinatorial structure of the meshes being cut by using their connectivity. Working with edge-face intersections suits working with input mesh topology to resolve the underlying connectivity, which has the following benefits: 1) limits the sources of floating-point roundoff error for improving robustness, and 2) permits a general solution to the \u2018mesh arrangements\u2019 problem, catering to configurations like slicing with arbitrary manifold shapes and surfaces (i.e. open or closed).</p>"},{"location":"gallery/","title":"Gallery","text":"<p>This page shows a few examples of cutting meshes with MCUT.</p>"},{"location":"gallery/#lion-torus","title":"Lion &amp; torus","text":"<p>Input</p> <p></p> <p>Output</p> <p> </p>"},{"location":"gallery/#elephant","title":"Elephant","text":"<p>Input</p> <p></p> <p>Outputs</p> <p> </p>"},{"location":"gallery/#textures","title":"Textures","text":"<p>Input</p> <p></p> <p>Outputs</p> <p> </p>"},{"location":"license/","title":"Licensing","text":"<p>MCUT is available under an Open Source license as well as a commercial license. Users choosing to use MCUT under the free-of-charge Open Source license have to comply to its terms, otherwise they have to buy a commercial license.</p> <p>The Open Source license is the GNU Lesser General Public License, Version 3 (LGPL).</p> <p>Below is a brief overview of the license scheme and the rights given to users.</p>"},{"location":"license/#open-source-license","title":"Open source license","text":"<p>The code is released under the GPL in order to protect its commercial value. This allows for commercialisation, which guarantees long term support, maintenance and further developments of the code for the benefit of the project and its users.</p> <p>LGPL primer</p> <p>In general, users of code that is licensed under LGPL must:</p> <ul> <li>Include a copy of the full license text and the original copyright notice</li> <li>Make available the source updates when distributing a derivative work based on the licensed sofware</li> <li>License any derivative works of the sofware under the same or later version of the LGPL or GPL as described above</li> </ul> <p>In sum, the LGPL license gives you the right to use and copy the source code of MCUT freely. It is also possible to modify the MCUT code under the condition that the resulting modifications are released as source code under LGPL with any binary distribution of your software that uses these LGPL parts. </p>"},{"location":"license/#commercial-license","title":"Commercial license","text":"<p>The commercial license option is for users that wish to use MCUT in their products for commercial purposes but do not wish to release their software under the LGPL. You can buy a commercial license from CutDigital Enterprise. The commercial offer is adapted based on company size (number of employees).</p>"},{"location":"license/#philosophy","title":"Philosophy","text":"<p>The licensing model of MCUT is motivated by the desire to eliminate the access costs for users/creators of derivative works by minimising the restrictions posed by strict copyright rules. </p> <p>\u201cAccess costs\u201d refers to expenses for users that wish to e.g. do research or create a derivative work\u2014such as their own 3D mesh processing tool(s), a copy of MCUT modified to fix a bug, or add a feature\u2014but are unable (or perhaps even unwilling) to pay for the right to do so.</p> <p>This reduction of access costs also aims to increase usage by gaining \u201cmarket share\u201d, leading to even more frequent creation of derivative works. The by-product of this increased usage is further awareness e.g. through recommendations via networks, forums, word-of-mouth etc. The openness of MCUT\u00b4s development and its diverse user-base will also garner additional trust as a reliable tool that is also viable for commercial use.</p> <p>Being open also creates enormous value. For example, in the context of scientific research, MCUT\u00b4s functionality is shared for free and anyone with access to the source code can generate data (e.g. meshes, performance stats etc), develop simulations, and prototype geometry processing ideas amongst others. The original project may also receive feedback and potential improvements on the original design from the user community.</p>"},{"location":"product/","title":"The product","text":"<p>MCUT is distributed as a cross-platform software library (static or shared) exposing a classic C API which can be used in practically any C++ application.</p> <p>The primary function of MCUT is to take two meshes, resolve their intersection(s) and generate fragment pieces of the sliced shape. When a mesh is cut, your application simply invokes a dispatch call. The MCUT API can then be queried for the desired output, like the patches that were used for hole-filling etc.</p> <p>MCUT cuts with any 2-manifold surface. This has the advantages that it easy to slice a multitude of shapes - from using simple surfaces like quads to performing complex CSG operations using meshes of arbitrary shape. Furthermore, the cut mesh (your knife tool) does not depend on the complexity of the source mesh, thus alleviating numerous impinging constrants on what you can do with MCUT.</p> <p>The gist about how MCUT works are discussed in a Journal article which you can find here here.</p> <p>Armadillo sliced with planer cut.</p>"},{"location":"tutorials/connectedComponents/","title":"Connected components","text":"<p>TODO</p>"},{"location":"tutorials/contextInfo/","title":"Obtaining information about context state","text":"<p>MCUT uses several opaque data structures whose properties can be examined with functions named <code>mcGetXX</code>. Context objects are no exception. The <code>mcGetInfo</code> function provides information about a context object\u2019s state, and its signature is as follows</p> <pre><code>McResult mcGetInfo(\n    const McContext context,\n    McFlags info,\n    uint64_t bytes,\n    void* pMem,\n    uint64_t* pNumBytes);\n</code></pre> <p>These arguments are straightforward. The first three provide input: the context object, a name that identifies the type of data you\u2019re requesting, and the amount of data you\u2019re requesting. The last two arguments are output arguments, in which the function returns the data you\u2019re requesting and the size of the returned data.</p> <p>The data type of the fourth argument is dependant on the second argument. The second argument is an enumerated type that can take any of the values in the following table:</p> Parameter name Parameter value Purpose <code>MC_CONTEXT_FLAGS</code> <code>McFlags</code> Returns a bitfield encoding the flags used to create the context. <code>MC_DEFAULT_PRECISION</code> <code>uint64_t</code> Default number of bits used to represent the significand of a floating-point number. <code>MC_DEFAULT_ROUNDING_MODE</code> <code>McRoundingModeFlags</code> Default way to round the result of a floating-point operation. <code>MC_PRECISION_MAX</code> <code>uint64_t</code> Maximum value for precision bits. <code>MC_PRECISION_MIN</code> <code>uint64_t</code> Minimum value for precision bits. <p>Here is an example of how to use the <code>mcGetInfo</code> function:</p> <pre><code>McFlags defaultRoundingMode = 0;\nuint64_t numBytes = 0;\nMcResult err = mcGetInfo(context, MC_DEFAULT_ROUNDING_MODE, 0, nullptr, &amp;numBytes);\nif(err)\n{\n    // ...\n}\n\nerr = mcGetInfo(context, MC_DEFAULT_ROUNDING_MODE, numBytes, &amp;defaultRoundingMode, nullptr);\n\nif(err)\n{\n    // ...\n}\n\nstd::fprintf(stdout, \"default precision: %\" PRId64 \"\\n\", (uint64_t)defaultPrec);\n</code></pre> <p>If MCUT has not been compiled with arbitrary-precision numbers, then information dependant on <code>MC_DEFAULT_PRECISION</code>, <code>MC_PRECISION_MAX</code> and <code>MC_PRECISION_MIN</code> should not be relied on. </p>"},{"location":"tutorials/debugging/","title":"Debugging","text":"<p>Using MCUT can be a lot of fun, but it may also be a source of frustration whenever something isn\u2019t working just right! Since most of what you will do involves working with geometry, it may be difficult to figure out the source of an error whenever something does not work as expected. </p> <p>In this tutorial we look into several ways of debugging your MCUT program. </p>"},{"location":"tutorials/debugging/#error-codes","title":"Error codes","text":"<p>All MCUT API functions return an error code. The error codes that functions can return are listed below:</p> Flag Description <code>MC_NO_ERROR</code> Everthing is fine. <code>MC_INVALID_OPERATION</code> The state for a command is not legal for its given parameters. <code>MC_INVALID_VALUE</code> Set when a value parameter is not legal. <code>MC_OUT_OF_MEMORY</code> Internal memory allocation failure. <p>Within MCUT\u2019s function documentation you can always find the error codes a function generates the moment it is incorrectly used. </p> <p>The great thing about returned error codes is that they makes it relatively easy to pinpoint where any error may be and to validate the proper use of MCUT. Let\u2019s say you query zero connected components after an <code>mcDispatch</code> call and you have no idea what\u2019s causing it: did the meshes intersect? Where the input meshes valid? By checking returned error flag all over your codebase, you can quickly catch the first place an MCUT error starts showing up.</p>"},{"location":"tutorials/debugging/#helper-functions","title":"Helper functions","text":"<p>The returned error codes are just numbers, which isn\u2019t easy to understand unless you\u2019ve memorized the error codes. It often makes sense to write a small helper function to easily print out the error strings together with where the error check function was called:</p> <pre><code>void mcCheckError_(McResult err, const char *file, int line)\n{\n    if(err != MC_NO_ERROR){\n        std::string errorStr;\n        switch (err)\n        {\n            case MC_INVALID_OPERATION:               errorStr = \"MC_INVALID_OPERATION\"; break;\n            // ...\n        }\n        std::cout &lt;&lt; errorStr &lt;&lt; \" | \" &lt;&lt; file &lt;&lt; \" (\" &lt;&lt; line &lt;&lt; \")\" &lt;&lt; std::endl;\n    }\n}\n\n#define mcCheckError(errCode) mcCheckError_(errCode, __FILE__, __LINE__) \n</code></pre> <p>We can then use this function as follows: <pre><code>// make some API call and return error code\nMcResult err = mcGetConnectedComponents(\n    context, \n    MC_CONNECTED_COMPONENT_TYPE_ALL, \n    0, \n    NULL, \n    &amp;numConnComps);\n\n// ... now check the error code\nmcCheckError(err);\n</code></pre></p>"},{"location":"tutorials/debugging/#debug-output","title":"Debug output","text":"<p>Helper functions are useful, but return codes alone can\u2019t help too much because information that functions will return is rather simple. However, it does often help you catch typos or quickly pinpoint where things went wrong.</p> <p>A more comprehensive tool is the debug output feature. With the debug output, MCUT will directly send an error or warning message to the user with a lot more details compared to returned codes. </p> <p>Not only does it provide more information, it can also help you catch errors exactly where they occur by intelligently using a debugger.</p> <p>To start using debug output we have to setup a debug context. This step is a matter of specifying a flag:</p> <pre><code>McContext context = MC_NULL_HANDLE;\nMcResult err = mcCreateContext(&amp;context, MC_DEBUG);\n\nif(err)\n{\n    // ...\n}\n</code></pre> <p>To check if we successfully initialized a debug context we can query MCUT as follows:</p> <pre><code>uint64_t numBytes = 0;\nMcFlags contextFlags;\n\nMcResult err = mcGetInfo(context, MC_CONTEXT_FLAGS, 0, nullptr, &amp;numBytes);\n\nif(err)\n{\n    // ...\n}\n\nerr = mcGetInfo(context, MC_CONTEXT_FLAGS, numBytes, &amp;contextFlags, nullptr);\n\nif(err)\n{\n    // ...\n}\n\nif (contextFlags &amp; MC_DEBUG) {\n    // do stuff with our debug context...\n}\n</code></pre> <p>The way debug output works is that we pass MCUT an error logging callback function. This callback function will be used to process the MCUT error data as we wish. For this particular example, we\u2019ll be displaying useful error data to the console. </p> <p>Here is the callback function prototype that MCUT expects for debug output:</p> <pre><code>void MCAPI_CALL (*pfn_mcDebugOutput_CALLBACK)(\n    McDebugSource source, \n    McDebugType type, \n    uint32_t id, \n    McDebugSeverity severity, \n    size_t length, \n    const char* message, \n    const void* userParam);\n</code></pre> <p>We can then create a useful error printing utility function like this:</p> <pre><code>extern MCAPI_ATTR void MCAPI_CALL mcDebugOutput(McDebugSource source,\n    McDebugType type,\n    unsigned int id,\n    McDebugSeverity severity,\n    size_t length,\n    const char* message,\n    const void* userParam)\n{\n    printf(\"---------------\\n\");\n    printf(\"Debug message ( %d ): %s \", id, message);\n\n    switch (source) {\n    case MC_DEBUG_SOURCE_API:\n        printf(\"Source: API\");\n        break;\n    case MC_DEBUG_SOURCE_KERNEL:\n        printf(\"Source: Kernel\");\n        break;\n        break;\n    }\n\n    printf(\"\\n\");\n\n    switch (type) {\n    case MC_DEBUG_TYPE_ERROR:\n        printf(\"Type: Error\");\n        break;\n    case MC_DEBUG_TYPE_DEPRECATED_BEHAVIOR:\n        printf(\"Type: Deprecated Behaviour\");\n        break;\n    case MC_DEBUG_TYPE_OTHER:\n        printf(\"Type: Other\");\n        break;\n    }\n\n    printf(\"\\n\");\n\n    switch (severity) {\n    case MC_DEBUG_SEVERITY_HIGH:\n        printf(\"Severity: high\");\n        break;\n    case MC_DEBUG_SEVERITY_MIDIUM:\n        printf(\"Severity: medium\");\n        break;\n    case MC_DEBUG_SEVERITY_LOW:\n        printf(\"Severity: low\");\n        break;\n    case MC_DEBUG_SEVERITY_NOTIFICATION:\n        printf(\"Severity: notification\");\n        break;\n    }\n\n    printf(\"\\n\\n\");\n}\n</code></pre> <p>Whenever debug output detects an MCUT error, it will call this callback function and we\u2019ll be able to print out a large deal of information regarding the MCUT error. </p> <p>Now that we have the callback function, the next step is to initialize debug output:</p> <pre><code>if (contextFlags &amp; MC_DEBUG) {\n    mcDebugMessageCallback(context, mcDebugOutput, nullptr);\n    mcDebugMessageControl(\n        context, \n        MC_DEBUG_SOURCE_ALL, \n        MC_DEBUG_TYPE_ALL, \n        MC_DEBUG_SEVERITY_ALL, \n        true);\n}\n</code></pre>"},{"location":"tutorials/debugging/#filtering-debug-output","title":"Filtering debug output","text":"<p>With <code>mcDebugMessageControl</code> you can filter the type(s) of errors you\u2019d like to receive a message from. In our case we decided to not filter on any of the sources, types, or severity rates. If we wanted to only show messages from the MCUT API, that are errors, and have a high severity, we\u2019d configure it as follows:</p> <pre><code>mcDebugMessageControl(\n    context, \n    MC_DEBUG_SOURCE_API, \n    MC_DEBUG_TYPE_ERROR, \n    MC_DEBUG_SEVERITY_HIGH, \n    true);\n</code></pre> <p>Given our configuration, and assuming you have a context that supports debug output, every incorrect MCUT command will now print a bunch of potentially useful data.</p> <p>Backtracking the debug error source</p> <p>Another great trick with debug output is that you can relatively easily figure out the exact line or call an error occurred. By setting a breakpoint in <code>mcDebugOutput</code> at a specific error type (or at the top of the function if you don\u2019t care), the debugger will catch the error thrown and you can move up the call stack to whatever function caused the message dispatch.</p>"},{"location":"tutorials/designPrincipals/","title":"Design principles","text":"<p>Here we summarize the design principles of MCUT:</p> <ul> <li> <p>Fast: Processing meshes with over 100k polygons in a few seconds.</p> </li> <li> <p>Robust: Thorougly tested and works with exact predicates. </p> </li> <li> <p>Simple: Straightforward and portable C-API.</p> </li> <li> <p>Minimal: Self-contained and without dependancies.</p> </li> </ul> <p>The above image depicts the gist of what MCUT does. On the left is a cube (the \u201csource mesh\u201d) that is cut by a circular surface (the \u201ccut mesh\u201d), which together comprise the input. On the right is the resulting set of connected components after partitioning the cube. In general, the output of MCUT includes unsealed fragments (mid-left), cut mesh patches (middle), and the sealed fragments whose holes have been filled with cut mesh polygons that lie on the interior of the source mesh. Sealing can also be done using cut mesh polygons that lie on the exterior of the source mesh. </p>"},{"location":"tutorials/exactCoords/","title":"Querying exact coordinates","text":"<p>As described in the meshes tutorial, mesh vertices that are represented using arbitrary precision will be specified using character strings (i.e. as <code>const char*</code>). A single string specifies the coordinates as a space-separated sequence of real numbers. (Tuples of three numbers are also possible, placing newline character in place of every third space character). </p> <p>With this format, this tutorial shows how to query/ask MCUT for vertex coordinates as a character string representing their exact values. </p> <p>The first step is querying the actual number of vertices (in a given connected component). We must explicitly query the number of vertices because this information cannot be inferred from the number of bytes - unlike <code>double</code> and <code>float</code>. </p> <pre><code>uint64_t vertexCountBytes = 0;\nMcResult err = mcGetConnectedComponentData(\n    context, \n    cc, // given connected component \n    MC_CONNECTED_COMPONENT_DATA_VERTEX_COUNT, \n    0, \n    NULL, \n    &amp;vertexCountBytes);\n\nif(err)\n{\n    // ...\n}\n\n// It possible to also directly query the number of vertices \n// since we know the number of bytes, which is a constant 4 bytes!\nuint32_t numberOfVertices = 0;\n\nMcResult err = mcGetConnectedComponentData(\n    context_, \n    cc, \n    MC_CONNECTED_COMPONENT_DATA_VERTEX_COUNT, \n    vertexCountBytes, \n    &amp;numberOfVertices, \n    NULL);\n\nif(err)\n{\n    // ...\n}\n</code></pre> <p>Once we know the number of vertices, the next step is querying the exact coordinates which we do as follows:</p> <pre><code>uint64_t connCompVerticesBytes = 0;\nMcResult err = mcGetConnectedComponentData(context_, cc, MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT, 0, NULL, &amp;connCompVerticesBytes);\n\nif(err)\n{\n    // ...\n}\n\nstd::vector&lt;char&gt; rawVerticesString;\nrawVerticesString.resize(connCompVerticesBytes);\n\nMcResult err = mcGetConnectedComponentData(context_, cc, MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT, connCompVerticesBytes, (void*)rawVerticesString.data(), NULL);\n\nif(err)\n{\n    // ...\n}\n\nauto isPartOfDigit = [&amp;](unsigned char ch) {\n    return ch == '.' || ch == '-' || std::isdigit(ch);\n};\n\nstd::vector&lt;char&gt; x;\nstd::vector&lt;char&gt; y;\nstd::vector&lt;char&gt; z;\n\nconst char* vptr = reinterpret_cast&lt;const char*&gt;(rawVerticesString.data());\nconst char* vptr_ = vptr; // shifted\n\n// for each number ...\nfor (uint32_t i = 0; i &lt; numberOfVertices * 3; ++i) {\n\n    vptr_ = std::strchr(vptr, ' '); // find next space\n\n    // length of string representing a number (very long!)\n    std::ptrdiff_t diff = vptr_ - vptr;\n    uint64_t srcStrLen = diff + 1; // extra byte for null-char\n\n    if (vptr_ == nullptr) {\n        srcStrLen = std::strlen(vptr) + 1;\n    }\n\n    if ((i % 3) == 0) { // x coord\n        x.resize(srcStrLen);\n        std::sscanf(vptr, \"%s\", &amp;x[0]);\n        x.back() = '\\0';\n\n        if(!isPartOfDigit(x[0]))\n        {\n            // ...\n        }\n    } else if ((i % 3) - 1 == 0) { // y coord\n        y.resize(srcStrLen);\n        std::sscanf(vptr, \"%s\", &amp;y[0]);\n        y.back() = '\\0';\n\n        if(!isPartOfDigit(y[0]))\n        {\n            // ...\n        }\n    } else if ((i % 3) - 2 == 0) { // z coord\n        z.resize(srcStrLen);\n        std::sscanf(vptr, \"%s\", &amp;z[0]);\n        z.back() = '\\0';\n\n        if(!isPartOfDigit(z[0]))\n        {\n            // ...\n        }\n    }\n\n    vptr = vptr_ + 1; // offset so that we point to the start of the next number/line\n}\n</code></pre> <p>Note that using <code>MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT</code> guarrantees exact numbers only if the following is true </p> <ol> <li><code>mcDispatch</code> was called with meshes defined using <code>MC_DISPATCH_VERTEX_ARRAY_EXACT</code>, and </li> <li>MCUT libary is implemented with arbitrary precision numbers enabled (see Compilation). </li> </ol> <p>Otherwise, the operation is equivalent to using <code>std::to_string</code> on values of type <code>float</code> or <code>double</code>, respectively.</p>"},{"location":"tutorials/helloWorld/","title":"Hello MCUT world","text":"<p>In this tutorial, we will look at simple HelloWorld-style example of an MCUT application. The purpose of the tutorial is to get you up to speed with using MCUT for cutting arbitrary meshes.</p>"},{"location":"tutorials/helloWorld/#input-meshes","title":"Input meshes","text":"<p>The first thing we will do is define our meshes, which are the source mesh and cut mesh. This section, describes how we define these meshes. </p>"},{"location":"tutorials/helloWorld/#the-source-mesh","title":"The source mesh","text":"<p>Here we will now define the source mesh, which will be cube as shown in the image below.</p> <p>The source mesh: a cube. </p> <pre><code>McFloat cubeVertices[] = {\n    -5, -5, 5, // 0\n    5, -5, 5, // 1\n    5, 5, 5, //2\n    -5, 5, 5, //3\n    -5, -5, -5, //4\n    5, -5, -5, //5\n    5, 5, -5, //6\n    -5, 5, -5 //7\n};\nMcUint32 cubeFaces[] = {\n    0, 1, 2, 3, //0\n    7, 6, 5, 4, //1\n    1, 5, 6, 2, //2\n    0, 3, 7, 4, //3\n    3, 2, 6, 7, //4\n    4, 5, 1, 0 //5\n};\nMcUint32 cubeFaceSizes[] = {\n    4, 4, 4, 4, 4, 4\n};\nMcUint32 numCubeVertices = 8;\nMcUint32 numCubeFaces = 6;\n</code></pre> <p>As you see, we just use simple C-style arrays to define the geometry and connectivity of our cube. This is all that MCUT needs to define a mesh: </p> <ul> <li>a list of vertices </li> <li>a list faces (indices)</li> <li>a list of face sizes (a value for each face)  </li> <li>the number of vertices</li> <li>the number of faces</li> </ul>"},{"location":"tutorials/helloWorld/#the-cut-mesh","title":"The cut mesh","text":"<p>Now that we have defined our source mesh, lets define the cut mesh. This will be the object that we will be slicing our cube with. Here is what the cut mesh looks like, and the code for defining this mesh is provided just below too.</p> <p>The cut mesh: a quad bent in the middle. </p> <pre><code>McFloat cutMeshVertices[] = {\n    -20, -4, 0, //0\n    0, 20, 20, //1\n    20, -4, 0, //2\n    0, 20, -20 //3\n};\nMcUint32 cutMeshFaces[] = {\n    0, 1, 2, //0\n    0, 2, 3 //1\n};\nMcUint32 cutMeshFaceSizes[] = {\n    3, 3\n};\nMcUint32 numCutMeshVertices = 4;\nMcUint32 numCutMeshFaces = 2;\n</code></pre> <p>Again, the data structures for defining our cut mesh are exactly the same as the source mesh. All we did was just change the data - simple.</p>"},{"location":"tutorials/helloWorld/#visualising-mesh-placement","title":"Visualising mesh placement","text":"<p>Before we proceed onto actually calling any MCUT functions, here is a visual depiction of the relative placement of the two meshes:</p> <p>A combined visualisation of our meshes, using their unmodified vertex coordinates.</p> <p>This relative positioning is determined by our vertex coordinates - as specified when we defined the meshes.</p>"},{"location":"tutorials/helloWorld/#using-the-mcut-api","title":"Using the MCUT API","text":"<p>Up to now, we have described how to define meshes in a suitable format for MCUT to read. This is the first step of using MCUT - actually defining the mesh data to use for cutting. In this section, we will now describe how to cut our cube mesh with the cut mesh using MCUT.</p>"},{"location":"tutorials/helloWorld/#creating-a-context","title":"Creating a context","text":"<p>First things first, we must create a context. MCUT contexts are represented by <code>McContext</code> data structures, and you can create them using:</p> <pre><code>McContext context = MC_NULL_HANDLE;\nmcCreateContext(&amp;context, MC_NULL_HANDLE);\n</code></pre> <p>MCUT uses the allocated context object to handle state, memory resources, etc. We can also think of <code>mcCreateContext</code> like the \u2018init\u2019 function (kinda\u2026). </p> <p>And thats pretty much it - thats all we need to do in order to \u201cinitialize\u201d MCUT before we can do the fun stuff. </p> <p>Lets do some cutting.</p>"},{"location":"tutorials/helloWorld/#the-dispatch-call","title":"The dispatch call","text":"<p>Now that we have our mesh data and a context has been created, the next step is cut the cube. To do this, we call the <code>mcDispatch</code> function like this:</p> <pre><code>mcDispatch(\n    context,\n    MC_DISPATCH_VERTEX_ARRAY_FLOAT,\n    cubeVertices,\n    cubeFaces,\n    cubeFaceSizes,\n    numCubeVertices,\n    numCubeFaces,\n    cutMeshVertices,\n    cutMeshFaces,\n    cutMeshFaceSizes,\n    numCutMeshVertices,\n    numCutMeshFaces);\n</code></pre> <p>\u2026 and that\u2019s it - we have cut our cube. Simple huh..? </p> <p>Before moving on to the next section, let peek at the parameters a bit. They seem a lot at-first-glance but if we look closer we can see that most of them are just our mesh variables that we defined previously. So they are covered. The first parameter is our context (of-course!) which will hold all information/state relating to our operation. The second parameter specifies how MCUT should interpret our vertex arrays (<code>cubeVertices</code> and <code>cutMeshVertices</code>). In this example, <code>MC_DISPATCH_VERTEX_ARRAY_FLOAT</code> means \u201cinterpret the data as 32-bit floats\u201d which must match with our arrays.</p>"},{"location":"tutorials/helloWorld/#wheres-my-output","title":"Where\u2019s my output?","text":"<p>At this point, MCUT has cut the cube, which was done by calling using the <code>mcDispatch</code> function. However, there\u2019s no evidence of output meshes anywhere in our code which we need to show that MCUT actually did something! So in this section, we will find out how to ask MCUT to give us the result(s) of the cutting operation that we just performed. </p>"},{"location":"tutorials/helloWorld/#how-many-meshes","title":"How many meshes?","text":"<p>The first step to getting our output from MCUT to query for how many meshes (otherwise known as \u201cconnected components\u201d) of a particular type are available. Since we are learning about what MCUT can do, we will request all of the output that resulted from our cube being cut. Here\u2019s how we do that:</p> <pre><code>McUint32 numConnComps;\nstd::vector&lt;McConnectedComponent&gt; connComps;\nmcGetConnectedComponents(context, MC_CONNECTED_COMPONENT_TYPE_ALL, 0, NULL, &amp;numConnComps);\nconnComps.resize(numConnComps);\nmcGetConnectedComponents(context, MC_CONNECTED_COMPONENT_TYPE_ALL, (McUint32)connComps.size(), connComps.data(), NULL);\n</code></pre> <p>Notice how we had to call <code>mcGetConnectedComponents</code> twice? We do this because in MCUT querying information is a two-step process. First you need to allocate memory for one or more structures. Then you need to initialize these structures. </p> <p>The code above calls <code>mcGetConnectedComponents</code> twice. The first time, it places the number of connected components in the <code>numConnComps</code> variable. The second time, it places <code>McConnectedComponent</code> structures in the <code>connComps</code> array. We\u2019ll employ this function-allocation-function procedure for many other types of queries as well.</p> <p>Notice that we also provided the parameter <code>MC_CONNECTED_COMPONENT_TYPE_ALL</code> which specifies that we want all connected components from MCUT. This allows for filtering to get just the connected components we want by specifying different values.</p>"},{"location":"tutorials/helloWorld/#accessing-mesh-data","title":"Accessing mesh data","text":"<p>Once we\u2019ve accessed an available connected component, we can access every type of data that we can query for one - like its vertices. </p> <p>In code, connected components (i.e. meshes) are represented by <code>McConnectedComponent</code> structures. These are easy to work with, and the functions that relate to connected component data are very similar to <code>mcGetConnectedComponents</code> from the preceding section. This section presents the another MCUT connected component function, <code>mcGetConnectedComponentData</code>, and shows how it is used in code.</p> <p>As its name implies, <code>mcGetConnectedComponentData</code> accepts a <code>McConnectedComponent</code> (amongst others) and provides information about the corresponding connected component. This operates in exactly the same way that <code>mcGetConnectedComponents</code> does: Identify the type of information you\u2019re looking for, and the function will place the data in the memory referenced.</p> <p>We will now show how to query connected componented data. Assume that these variables have been defined in the following snippets:</p> <pre><code>McConnectedComponent connComp = connComps[i]; // connected component handle.\nMcSize numBytes = 0; // number of bytes we must allocate.\n</code></pre> <p>And here is how we query the data of a connected component (vertices, faces etc.):</p> <p>query the vertices</p> <pre><code>mcGetConnectedComponentData(context, connComp, MC_CONNECTED_COMPONENT_DATA_VERTEX_FLOAT, 0, NULL, &amp;numBytes);\nstd::vector&lt;McFloat&gt; vertices;\nvertices.resize(numBytes / sizeof(McFloat)); //... or --&gt; numberOfVertices * 3\nmcGetConnectedComponentData(context, connComp, MC_CONNECTED_COMPONENT_DATA_VERTEX_FLOAT, numBytes, (void*)vertices.data(), NULL);\n</code></pre> <p>The number of vertices can be determined based on the type used to represent the queried vertices and the number of bytes:  <pre><code>McUint32 numberOfVertices = numBytes / (sizeof(McFloat)*3); // 3 floats per vertex\n</code></pre></p> <p>query the faces</p> <pre><code>mcGetConnectedComponentData(context, connComp, MC_CONNECTED_COMPONENT_DATA_FACE, 0, NULL, &amp;numBytes);\nstd::vector&lt;McUint32&gt; faceIndices;\nfaceIndices.resize(numBytes / sizeof(McUint32));\nmcGetConnectedComponentData(context, connComp, MC_CONNECTED_COMPONENT_DATA_FACE, numBytes, faceIndices.data(), NULL);\n</code></pre> <p>query the face sizes</p> <pre><code>mcGetConnectedComponentData(context, connComp, MC_CONNECTED_COMPONENT_DATA_FACE_SIZE, 0, NULL, &amp;numBytes);\nstd::vector&lt;McUint32&gt; faceSizes;\nfaceSizes.resize(numBytes / sizeof(McUint32));\nmcGetConnectedComponentData(context, connComp, MC_CONNECTED_COMPONENT_DATA_FACE_SIZE, numBytes, faceSizes.data(), NULL);\n</code></pre> <p>Glancing through the code, its fairly easy to see that we are using <code>mcGetConnectedComponentData</code> similarly to the way we used <code>mcGetConnectedComponents</code> in the previous section, which makes the library very easy to use.</p> <p>We are done! So lets clean up before seeing our results and wrapping up below.</p>"},{"location":"tutorials/helloWorld/#cleaning-up","title":"Cleaning up","text":"<p>Now that we have finished using MCUT, we must free all resources that were allocated for our connected components. Since we want to free all connected component data, we will just do:</p> <pre><code>mcReleaseConnectedComponents(context, 0, NULL);\n</code></pre> <p>\u2026 which will release the resources held by the library for all connected components.</p> <p>Finally, we will also destroy our context since we will not be performing any further cutting operations. Here\u2019s how we do that:</p> <pre><code>mcReleaseContext(context);\n</code></pre>"},{"location":"tutorials/helloWorld/#results","title":"Results","text":"<p>In this section, we show the meshes produced as a result of cutting our cube with MCUT.</p> <p>Internally sealed fragments</p> <p>Here we show the canonical results of the cut, which are the two watertight fragments of our cube. We have effectively cut and filled the holes in our cube to produce the fragments.</p> <p>Internally-sealed lower fragment.</p> <p>Internally-sealed upper fragment.</p> <p>Externally sealed fragments</p> <p>Here we show an odd but unique case, which is an example of sealing our cube from the outside. </p> <p>Externally-sealed lower fragment.</p> <p>Externally-sealed upper fragment.</p> <p>Such a result is readily produced by MCUT, and is the cornerstone of MCUT\u2019s support of CSG (boolean) operations. As you may imagine, this feature enables new techniques and effects for mesh editing tools.</p> <p>Unsealed fragments</p> <p>In this example, we show that not only can MCUT produce watertight and externally sealed meshes, but that MCUT can also provide the unsealed fragments of the source mesh. It is also possible to retrieve partially sealed meshes which is not shown here.</p> <p>Unsealed lower fragment.</p> <p>Unsealed upper fragment.</p> <p>Patches</p> <p>While the focus is generally on the source much, the versatility MCUT also allows us to create cut-outs of the cut mesh.</p> <p>Interior patch.</p> <p>Exterior patch.</p> <p>We refer to this as stencilling. The left image show the interior patch of the cut surface, which can be used for emulating effects like \u201cgingerbread man\u201d style cut-outs. On the right, we show the exterior patch which likewise holds potential use-cases of its own. One example application, is producing silhouette cut-outs for simulating deformation or cloth-like effects on intricate geometries. </p> <p>Seams</p> <p>Finally, in this example we show that MCUT can also be used as a practical tool for computing intersection contours. These are the paths of intersection between the source mesh and cut mesh.</p> <p>Source mesh with added seam.</p> <p>Cut mesh with added seam.</p> <p>One example application of seams is global intersection analysis in character animation, which is the backbone of industry-standard collision-response algorithms for unoriented objects like cloth. A key point to note here is that this feature results directly from the generality of MCUT, resolving mesh intersections using the half-edge data structure. </p>"},{"location":"tutorials/helloWorld/#summary","title":"Summary","text":"<p>In this tutorial, we have looked a simple HelloWorld-style of application using MCUT. First, mesh initialisation was described, showing that defining a mesh boils doing to simple C-style arrays. We then proceeded to create an MCUT context, which allowed us to submit a dispatch call to do the cutting. We demonstrated that all of these steps were brief and simple. Next, we delved into the task of querying data from MCUT after a dispatch call. In this regard, we found out how MCUT uses a \u201cfunction-allocation-function procedure\u201d to query information. This was then used to access connected components (our meshes), and their data (vertices, face indices etc.). Finally, we finished off by showing how to free internal memory allocated by the MCUT library, and then topped off with some nice visualisations of the output meshes.</p>"},{"location":"tutorials/meshes/","title":"Meshes","text":"<p>This tutorial walks through the basics of MCUT, showing how to define a mesh and iterate through its vertices and faces.</p> <p>A mesh represents a two-manifold surface, where each edge is incident to one or two faces.</p> <p>An example of a 2-manifold mesh. </p> <p>Meshes in MCUT are represented as simple arrays of builtin C/C++ data types. In particular, users are permitted to use three C/C++ types when specifying vertex coordinates.  These are <code>float</code> and <code>double</code>.</p>"},{"location":"tutorials/meshes/#32-bit-float-vertex-arrays","title":"32-bit <code>float</code> vertex arrays","text":"<p>The following is an example of how to define a mesh using the <code>float</code> data type to represent vertex positions:</p> <pre><code>McFloat pMeshVertices[] = { // xyz|xyz|x...\n  -10.f, -5.f, 0.f, // vertex 0\n  -10.f, 5.f, 0.f, // vertex 1\n  10.f, 5.f, 0.f,\n  10.f, -5.f, 0.f,\n  5.f, 0.f, 0.f,\n  0.f, -5.f, 0.f,\n  -5.f, 0.f, 0.f,\n  -10.f, -10.f, 0.f,\n  10.f, -10.f, 0.f,\n  15.f, 5.f, 0.f,\n  15.f, -10.f, 0.f\n};\nMcUint32 pMeshFaceIndices[] = {\n  0, 6, 5, 4, 3, 2, 1, // face 0\n  0, 7, 8, 3, 4, 5, 6, // face 1\n  8, 10, 9, 2, 3 // face 2\n};\nMcFaceSize pMeshFaceSizes[] = {7, 7, 5};\nMcUint32 numMeshVertices = 11;\nMcUint32 numMeshFaces = 3;\n</code></pre>"},{"location":"tutorials/meshes/#64-bit-double-vertex-arrays","title":"64-bit <code>double</code> vertex arrays","text":"<p>Using the same mesh example, the following except shows how to specify vertices as an array of <code>double</code>:</p> <pre><code>McDouble pMeshVertices[] = { \n  -10.0, -5.0, 0.0, \n  -10.0, 5.0, 0.0, \n  10.0, 5.0, 0.0,\n  10.0, -5.0, 0.0,\n  5.0, 0.0, 0.0,\n  0.0, -5.0, 0.0,\n  -5.0, 0.0, 0.0,\n  -10.0, -10.0, 0.0,\n  10.0, -10.0, 0.0,\n  15.0, 5.0, 0.0,\n  15.0, -10.0, 0.0\n};\n</code></pre>"},{"location":"tutorials/meshes/#accessing-mesh-elements","title":"Accessing mesh elements","text":"<p>As a simple demonstration of the mesh data structure defined above, let us iterate through the vertices and faces of the mesh. </p> <pre><code>// vertices\nfor (McUint32 i = 0; i &lt; numMeshVertices; ++i) {\n  // assuming float\n  McFloat x = pMeshVertices[i*3 +0];\n  McFloat y = pMeshVertices[i*3 +1];\n  McFloat z = pMeshVertices[i*3 +2];\n\n  printf(\"vertex: %f %f %f\\n\", x, y, z);\n}\n\n// faces\nMcUint32 base = 0;\nfor(McInt32 i = 0; i &lt; numMeshFaces; ++i){\n  McUint32 numFaceVertices = pMeshFaceSizes[i];\n  printf(\"face %d (%hu vertices):\", i, numFaceVertices);\n  for(McUint32 j = 0; j &lt; numFaceVertices; ++j)  {\n    printf(\" %u\", pMeshFaceIndices[base+j]);\n  }\n  printf(\"\\n\");\n  base += numFaceVertices;\n}\n</code></pre>"}]}