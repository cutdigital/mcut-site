{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 What you can do with MCUT: A Max Planck model cuts a cube. MCUT (pronounced \u2018emcut\u2019) is a tool for cutting meshes: It is a library for partitioning surface-meshes using their geometry to produce crisp fragments at fine scale, which is useful for operations like slicing and boolean operations. Supported features include stencilling (exact cut-outs of the cutting surface), intersection-curve queries and partial cuts. MCUT is a tool providing a general solution to the problem of resolving mesh intersections. Design principles \u00b6 The design principles of MCUT are as follows: Fast : Multi-threaded processing of dense meshes with minimal overhead. Robust : Thorougly tested and works with exact predicates. Simple : Straightforward and portable C-API. Minimal : Self-contained and without dependancies. An illustrative gist of what MCUT does: On the left is a cube (the \"source mesh\") that is cut by a circular surface (the \"cut mesh\"), which together comprise the input. On the right is the resulting set of connected components after partitioning the cube. In general, the output of MCUT includes unsealed fragments (mid-left), cut mesh patches (middle), and the sealed fragments whose holes have been filled with cut mesh polygons that lie on the interior of the source mesh. Sealing can also be done using cut mesh polygons that lie on the exterior of the source mesh. . Motivation \u00b6 Mesh cutting is fundamental and useful for solving a wide set of problems. The goal is to split a given surface mesh into a set of disjoint parts using another surface mesh. These resulting parts are typically employed in model design and/or simulation, such as virtual surgery, game level-design, computer aided design and manufacturing. Despite existing tools (e.g. CGAL , Cork , Carve , PWN or TetMesh tools ), it remains a challenge to slice meshes without restrictive assumptions on the input. Moreover, besides traditional CSG operations, most sophisticated modelling software (e.g. Maya , Cinema4D , Blender , MeshMixer , ANSYS SpaceClaim etc.) allow users only to cut meshes with a plane which restricts modelling and design capabilities. Features \u00b6 In addition to being simple, fast and robust, MCUT is specifically designed to be a cutting tool which supports the following features: Manifold meshes : open (with borders/boundaries), or closed (as in \u2018watertight\u2019). Partial cuts : A sliced object need not be completely cut into disjoint parts. Stencilling : Silhouette cut-outs of the cutting surface patches. Intersection curves : Query vertices introduced as a result of a cut. Booleans : Traditional CSG operations. N-gons : Arbitrary planar-polygon meshes. An extreme example, which is a result of cutting a source mesh that has concave polygons. The source mesh was a pentagonal frustum with the pentagons (top and bottom faces) made concave (and not parallel to each other). Each pentagon was composed of polygons with several concavities. The whole model was composed of only one volume element (all edges are on the surface). MCUT produces the correct fragments, and does not modify the connectivity except where intersected with the cut mesh.","title":"Home"},{"location":"#home","text":"What you can do with MCUT: A Max Planck model cuts a cube. MCUT (pronounced \u2018emcut\u2019) is a tool for cutting meshes: It is a library for partitioning surface-meshes using their geometry to produce crisp fragments at fine scale, which is useful for operations like slicing and boolean operations. Supported features include stencilling (exact cut-outs of the cutting surface), intersection-curve queries and partial cuts. MCUT is a tool providing a general solution to the problem of resolving mesh intersections.","title":"Home"},{"location":"#design-principles","text":"The design principles of MCUT are as follows: Fast : Multi-threaded processing of dense meshes with minimal overhead. Robust : Thorougly tested and works with exact predicates. Simple : Straightforward and portable C-API. Minimal : Self-contained and without dependancies. An illustrative gist of what MCUT does: On the left is a cube (the \"source mesh\") that is cut by a circular surface (the \"cut mesh\"), which together comprise the input. On the right is the resulting set of connected components after partitioning the cube. In general, the output of MCUT includes unsealed fragments (mid-left), cut mesh patches (middle), and the sealed fragments whose holes have been filled with cut mesh polygons that lie on the interior of the source mesh. Sealing can also be done using cut mesh polygons that lie on the exterior of the source mesh. .","title":"Design principles"},{"location":"#motivation","text":"Mesh cutting is fundamental and useful for solving a wide set of problems. The goal is to split a given surface mesh into a set of disjoint parts using another surface mesh. These resulting parts are typically employed in model design and/or simulation, such as virtual surgery, game level-design, computer aided design and manufacturing. Despite existing tools (e.g. CGAL , Cork , Carve , PWN or TetMesh tools ), it remains a challenge to slice meshes without restrictive assumptions on the input. Moreover, besides traditional CSG operations, most sophisticated modelling software (e.g. Maya , Cinema4D , Blender , MeshMixer , ANSYS SpaceClaim etc.) allow users only to cut meshes with a plane which restricts modelling and design capabilities.","title":"Motivation"},{"location":"#features","text":"In addition to being simple, fast and robust, MCUT is specifically designed to be a cutting tool which supports the following features: Manifold meshes : open (with borders/boundaries), or closed (as in \u2018watertight\u2019). Partial cuts : A sliced object need not be completely cut into disjoint parts. Stencilling : Silhouette cut-outs of the cutting surface patches. Intersection curves : Query vertices introduced as a result of a cut. Booleans : Traditional CSG operations. N-gons : Arbitrary planar-polygon meshes. An extreme example, which is a result of cutting a source mesh that has concave polygons. The source mesh was a pentagonal frustum with the pentagons (top and bottom faces) made concave (and not parallel to each other). Each pentagon was composed of polygons with several concavities. The whole model was composed of only one volume element (all edges are on the surface). MCUT produces the correct fragments, and does not modify the connectivity except where intersected with the cut mesh.","title":"Features"},{"location":"bug-report/","text":"Before asking about an issue, please check the following: Tip Read the FAQ before asking a new question, search existing issues for a problem similar to yours. Check the tutorials . General issues Be up-to-date with the master branch, and ensure that your issue has not already been fixed. To report a problem about the website (out-of-date content, erroneous instructions etc.), open an issue in the designated repository for the website.","title":"Bug report"},{"location":"building/","text":"Compilation \u00b6 MCUT is hosted on Github . System requirements CMake. C++11 compiler support. Setup git clone https://github.com/cutdigital/mcut.git cd mcut/ mkdir build cd build cmake .. Refer to the mcut/CMakeLists.txt for information about additional configuration flags.","title":"Build"},{"location":"building/#compilation","text":"MCUT is hosted on Github . System requirements CMake. C++11 compiler support. Setup git clone https://github.com/cutdigital/mcut.git cd mcut/ mkdir build cd build cmake .. Refer to the mcut/CMakeLists.txt for information about additional configuration flags.","title":"Compilation"},{"location":"changelog/","text":".md-nav--secondary .md-nav__list .md-nav__list { display: none } Changelog \u00b6 Summary Table \u00b6 Click to unroll. Version Short description master version 1.0.0 content 1.0.0 Major release: API, tutorials, MPFR support Future editions \u00b6 Querying partially sealed fragments More tutorials Multi-threading Events Profiling Timers Propagating vertex attributes (UVs etc.) Upcoming version ( master branch) \u00b6 New Features \u00b6 Performance improvements Version 1.0 Changes \u00b6 Our first release marks our confidence that this library can be used outside of casual experimenting. Arbitrary manifold meshes. Partial cut intersections. Stencilling. Intersection path queries Booleans N-gons","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#summary-table","text":"Click to unroll. Version Short description master version 1.0.0 content 1.0.0 Major release: API, tutorials, MPFR support","title":"Summary Table"},{"location":"changelog/#future-editions","text":"Querying partially sealed fragments More tutorials Multi-threading Events Profiling Timers Propagating vertex attributes (UVs etc.)","title":"Future editions"},{"location":"changelog/#upcoming-version-master-branch","text":"","title":"Upcoming version (master branch)"},{"location":"changelog/#new-features","text":"Performance improvements","title":"New Features"},{"location":"changelog/#version-10-changes","text":"Our first release marks our confidence that this library can be used outside of casual experimenting. Arbitrary manifold meshes. Partial cut intersections. Stencilling. Intersection path queries Booleans N-gons","title":"Version 1.0 Changes"},{"location":"faq/","text":"FAQ \u00b6 Is MCUT restricted to triangle meshes? No. MCUT is designed to work with meshes that are made with arbitrary simple polygons. These polygons can be convex or concave, so triangle meshes are just a special case. Is it possible that MCUT can fail to fill holes in sliced objects? MCUT can never fail to fill holes because the output meshes are produced by resolving/tracing the halfedge connectivity of input meshes. This is different from winding numbers and improves overall robustness since numerical operations are performed only when resolving polygon intersections. Does MCUT do automatic triangulation after cutting e.g. for rendering? Yes. MCUT also provides functionality to query the exact faces/polygons (which may be convex and/or concave) that are produced as a result of an intersection between two meshes. Can MCUT cut more than two meshes at the same time? MCUT is designed to work at-most with two meshes at a time. This simplifies reasoning about the implementation. I wish to slice a tetrahedral/hexahedral mesh using MCUT - is this possible? In general, no. This is because tetrahedral/hexahedral meshes are non-manifold, which is beyond the scope of MCUT. However, you may be able to use MCUT as a building block to cut individual cells (tetrahedra/hexahedra) of your mesh with the given cutting surface. This of course implies that you must then resolve the connectivity of your non-manifold mesh manually, effectively building on top of MCUT. Can the cut surface be a non-manifold mesh? No. The cut surface must always be a manifold surface mesh. What constitues a valid mesh for MCUT? A valid mesh is a connected component which is a manifold surface that has no self-intersections involving polygons along the cut (e.g. potentially intersecting polygons). We take the definition of manifold to be a mesh where every edge is incident to (i.e. used by) one or two faces. Where can I find the documentation for using MCUT? Function documentation is provided in the main header file, which is include/mcut/mcut.h . There are three options for viewing this documentation: 1) building the docs with doxygen (see Compilation ), 2) doing a Ctrl+F on mcut.h in your favourite text editor/IDE, and 3) using the github search function in the MCUT repository . The tutorials are also useful. What is a \u2018mesh\u2019? A mesh is a data structure consisting of a set of input vertices, edges, faces and topological relations between them. This data structure defines how each element is stored. What is a \u2018connected component\u2019? A connected component is the general name given to a mesh. In particular, it has the property that for any two faces in this mesh, there is a path of adjacent faces such that all edges between two consecutive faces of the path are not marked as constrained. What is a \u2018source mesh\u2019? A source mesh is the input mesh you want to cut. What is a \u2018cut mesh\u2019? A cut mesh is the input mesh you want to cut with (i.e. the knife tool). What is a \u2018fragment\u2019? A fragment is a connected component that resulted from partitioning the source mesh - sealed or unsealed. What is a \u2018patch\u2019? A patch is a connected component that is used to a seal hole in a fragment. It is a piece produced from the cut mesh. What is a \u2018seam\u2019 connected component? A connected component produced by MCUT which is same as an input mesh (source mesh or cut mesh) except that it has new edges which are placed according to the cut. What is the meaning of \u2018fragment location\u2019? The relative location of a fragment with respect to the cut mesh, which is determined by the face orientation (winding order) of the cut mesh. Example : A tetrahedron (source mesh) that is sliced in the middle with a quad (cut mesh), where the apex lies in the normal direction of the quad. In this case, the apex fragment is considered \u2018above\u2019, while the 6 sided fragment is considered \u2018below\u2019. What is the meaning of \u2018patch location\u2019? The relative location of a patch with respect to the source mesh, which is determined by the face orientation (winding order) of the source mesh. Intuitively, the subset of cut mesh polygons\u2013after clipping\u2013that lie inside (say, a watertight) source mesh are considered \u2018inside\u2019, and those not as \u2018outside\u2019. Must all input meshes have a consistent winding order? Yes. All input meshes must have a consistent winding order, but this order can be either clock-wise (CW) or counter clock-wise (CCW). Note however, that the source mesh can be CCW while the cut mesh is CW, and vice-versa . Degenerate inputs (not in general position) MCUT expects that all polygon intersections can be reduced to edge-face intersections. Thus, MCUT is designed for inputs in \u201cgeneral position\u201d, but also provides a crude workaround for degenerate inputs. Here the notion of general position is defined with respect to the orientation predicate: a set of points is in general position if no three points (where two points are from the same input mesh) are collinear, or that no four points (where three points from the same input mesh) are coplanar. The definition of \u201cinputs\u201d is relaxed here: i.e. only considering the list of pairs of polygons from the source-mesh and cut-mesh that are tested for intersection. Thus, the polygons that are not intersecting in any form (i.e. even not touching) do not have to be in general position. MCUT will use numerical perturbation of the cut-mesh so as to bring the input into general position. In such cases, the idea is to solve the cutting problem not on the given input, but on a nearby input. The nearby input is obtained by perturbing the given input. The perturbed input will then be in general position and, since it is near the original input, the result for the perturbed input will hopefully still be useful. This is justified by the fact that the task of MCUT is not to decide whether the input is in general position but rather to make perturbation on the input (if) necessary within the available precision of the computing device. Perturbation is enabled by including the appropriate MC_DISPATCH_ENFORCE_GENERAL_POSITION flag when calling the mcDispatch function, which is the crude workaround for degenerate inputs. Note: MCUT does not use symbolic perturbation since correct labelling of polygon intersection points is dependent on orientation predicates giving true answer i.e. orient3d and orient2d must return one of three values {-1, 0, +1} and not two {-1 or +1}, which is the essence of symbolic perturbation. The reason for MCUT doing this is that it allows us to identify intersection points \u2018topologically\u2019 and ensure that the entire implementation is free of numerical operations, except when dealing with polygon intersection points. Under the assumption of general position, intersection points can be uniquely identified according to the faces (from the source mesh and cut-mesh) that meet there, as well as the (half)edge that intersected a face to yeild that point. A key objective in the design of MCUT is to resolve the combinatorial structure of the meshes being cut by using their connectivity. Working with edge-face intersections suits working with input mesh topology to resolve the underlying connectivity, which has the following benefits: 1) limits the sources of floating-point roundoff error for improving robustness, and 2) permits a general solution to the \u2018mesh arrangements\u2019 problem, catering to configurations like slicing with arbitrary manifold shapes and surfaces (i.e. open or closed).","title":"FAQ"},{"location":"faq/#faq","text":"Is MCUT restricted to triangle meshes? No. MCUT is designed to work with meshes that are made with arbitrary simple polygons. These polygons can be convex or concave, so triangle meshes are just a special case. Is it possible that MCUT can fail to fill holes in sliced objects? MCUT can never fail to fill holes because the output meshes are produced by resolving/tracing the halfedge connectivity of input meshes. This is different from winding numbers and improves overall robustness since numerical operations are performed only when resolving polygon intersections. Does MCUT do automatic triangulation after cutting e.g. for rendering? Yes. MCUT also provides functionality to query the exact faces/polygons (which may be convex and/or concave) that are produced as a result of an intersection between two meshes. Can MCUT cut more than two meshes at the same time? MCUT is designed to work at-most with two meshes at a time. This simplifies reasoning about the implementation. I wish to slice a tetrahedral/hexahedral mesh using MCUT - is this possible? In general, no. This is because tetrahedral/hexahedral meshes are non-manifold, which is beyond the scope of MCUT. However, you may be able to use MCUT as a building block to cut individual cells (tetrahedra/hexahedra) of your mesh with the given cutting surface. This of course implies that you must then resolve the connectivity of your non-manifold mesh manually, effectively building on top of MCUT. Can the cut surface be a non-manifold mesh? No. The cut surface must always be a manifold surface mesh. What constitues a valid mesh for MCUT? A valid mesh is a connected component which is a manifold surface that has no self-intersections involving polygons along the cut (e.g. potentially intersecting polygons). We take the definition of manifold to be a mesh where every edge is incident to (i.e. used by) one or two faces. Where can I find the documentation for using MCUT? Function documentation is provided in the main header file, which is include/mcut/mcut.h . There are three options for viewing this documentation: 1) building the docs with doxygen (see Compilation ), 2) doing a Ctrl+F on mcut.h in your favourite text editor/IDE, and 3) using the github search function in the MCUT repository . The tutorials are also useful. What is a \u2018mesh\u2019? A mesh is a data structure consisting of a set of input vertices, edges, faces and topological relations between them. This data structure defines how each element is stored. What is a \u2018connected component\u2019? A connected component is the general name given to a mesh. In particular, it has the property that for any two faces in this mesh, there is a path of adjacent faces such that all edges between two consecutive faces of the path are not marked as constrained. What is a \u2018source mesh\u2019? A source mesh is the input mesh you want to cut. What is a \u2018cut mesh\u2019? A cut mesh is the input mesh you want to cut with (i.e. the knife tool). What is a \u2018fragment\u2019? A fragment is a connected component that resulted from partitioning the source mesh - sealed or unsealed. What is a \u2018patch\u2019? A patch is a connected component that is used to a seal hole in a fragment. It is a piece produced from the cut mesh. What is a \u2018seam\u2019 connected component? A connected component produced by MCUT which is same as an input mesh (source mesh or cut mesh) except that it has new edges which are placed according to the cut. What is the meaning of \u2018fragment location\u2019? The relative location of a fragment with respect to the cut mesh, which is determined by the face orientation (winding order) of the cut mesh. Example : A tetrahedron (source mesh) that is sliced in the middle with a quad (cut mesh), where the apex lies in the normal direction of the quad. In this case, the apex fragment is considered \u2018above\u2019, while the 6 sided fragment is considered \u2018below\u2019. What is the meaning of \u2018patch location\u2019? The relative location of a patch with respect to the source mesh, which is determined by the face orientation (winding order) of the source mesh. Intuitively, the subset of cut mesh polygons\u2013after clipping\u2013that lie inside (say, a watertight) source mesh are considered \u2018inside\u2019, and those not as \u2018outside\u2019. Must all input meshes have a consistent winding order? Yes. All input meshes must have a consistent winding order, but this order can be either clock-wise (CW) or counter clock-wise (CCW). Note however, that the source mesh can be CCW while the cut mesh is CW, and vice-versa . Degenerate inputs (not in general position) MCUT expects that all polygon intersections can be reduced to edge-face intersections. Thus, MCUT is designed for inputs in \u201cgeneral position\u201d, but also provides a crude workaround for degenerate inputs. Here the notion of general position is defined with respect to the orientation predicate: a set of points is in general position if no three points (where two points are from the same input mesh) are collinear, or that no four points (where three points from the same input mesh) are coplanar. The definition of \u201cinputs\u201d is relaxed here: i.e. only considering the list of pairs of polygons from the source-mesh and cut-mesh that are tested for intersection. Thus, the polygons that are not intersecting in any form (i.e. even not touching) do not have to be in general position. MCUT will use numerical perturbation of the cut-mesh so as to bring the input into general position. In such cases, the idea is to solve the cutting problem not on the given input, but on a nearby input. The nearby input is obtained by perturbing the given input. The perturbed input will then be in general position and, since it is near the original input, the result for the perturbed input will hopefully still be useful. This is justified by the fact that the task of MCUT is not to decide whether the input is in general position but rather to make perturbation on the input (if) necessary within the available precision of the computing device. Perturbation is enabled by including the appropriate MC_DISPATCH_ENFORCE_GENERAL_POSITION flag when calling the mcDispatch function, which is the crude workaround for degenerate inputs. Note: MCUT does not use symbolic perturbation since correct labelling of polygon intersection points is dependent on orientation predicates giving true answer i.e. orient3d and orient2d must return one of three values {-1, 0, +1} and not two {-1 or +1}, which is the essence of symbolic perturbation. The reason for MCUT doing this is that it allows us to identify intersection points \u2018topologically\u2019 and ensure that the entire implementation is free of numerical operations, except when dealing with polygon intersection points. Under the assumption of general position, intersection points can be uniquely identified according to the faces (from the source mesh and cut-mesh) that meet there, as well as the (half)edge that intersected a face to yeild that point. A key objective in the design of MCUT is to resolve the combinatorial structure of the meshes being cut by using their connectivity. Working with edge-face intersections suits working with input mesh topology to resolve the underlying connectivity, which has the following benefits: 1) limits the sources of floating-point roundoff error for improving robustness, and 2) permits a general solution to the \u2018mesh arrangements\u2019 problem, catering to configurations like slicing with arbitrary manifold shapes and surfaces (i.e. open or closed).","title":"FAQ"},{"location":"gallery/","text":"Gallery \u00b6 This page shows a few examples of cutting meshes with MCUT. Lion & torus \u00b6 Input Output Elephant \u00b6 Input Outputs Textures \u00b6 Input Outputs","title":"Gallery"},{"location":"gallery/#gallery","text":"This page shows a few examples of cutting meshes with MCUT.","title":"Gallery"},{"location":"gallery/#lion-torus","text":"Input Output","title":"Lion &amp; torus"},{"location":"gallery/#elephant","text":"Input Outputs","title":"Elephant"},{"location":"gallery/#textures","text":"Input Outputs","title":"Textures"},{"location":"license/","text":"Licensing \u00b6 MCUT is available under an Open Source license as well as a commercial license . Users choosing to use MCUT under the free-of-charge Open Source license have to comply to its terms, otherwise they have to buy a commercial license. The Open Source license is the GNU General Public License (GPL). Below is a brief overview of the license scheme and the rights given to users. Open source license \u00b6 The code is released under the GPL in order to protect its commercial value. This allows for commercialisation, which guarantees long term support, maintenance and further developments of the code for the benefit of the project and its users. GPL primer GPL (v3+) is an Open Source license that, gives you the right to use, copy and modify the code freely. If you distribute your software based on GPL (i.e. without purchasing the commercial license), then the following applies You are obliged to distribute the modifications of MCUT you made, and You are furthermore obliged to distribute the source code of your own software under the GPL. Commercial license \u00b6 In cases where the constraints of the Open source license prevent you from using MCUT, you can buy a commercial license. The commercial license includes the full source code for MCUT and any associated tools, ongoing technical support, and all future updates at no additional cost. The commercial license also allows MCUT to be used in an unlimited number of products developed by a company. Email the author for further information. Philosophy \u00b6 The licensing model of MCUT is motivated by the desire to eliminate the access costs for users/creators of derivative works by minimising the restrictions posed by strict copyright rules. \u201cAccess costs\u201d refers to expenses for users that wish to e.g. do research or create a derivative work\u2014such as their own 3D mesh processing tool(s), a copy of MCUT modified to fix a bug, or add a feature\u2014but are unable (or perhaps even unwilling) to pay for the right to do so. This reduction of access costs also aims to increase usage by gaining \u201cmarket share\u201d, leading to even more frequent creation of derivative works. The by-product of this increased usage is further awareness e.g. through recommendations via networks, forums, word-of-mouth etc. The openness of MCUT\u00b4s development and its diverse user-base will also garner additional trust as a reliable tool that is also viable for commercial use. Being open also creates enormous value. For example, in the context of scientific research, MCUT\u00b4s functionality is shared for free and anyone with access to the source code can generate data (e.g. meshes, performance stats etc), develop simulations, and prototype geometry processing ideas amongst others. The original project may also receive feedback and potential improvements on the original design from the user community.","title":"Licensing"},{"location":"license/#licensing","text":"MCUT is available under an Open Source license as well as a commercial license . Users choosing to use MCUT under the free-of-charge Open Source license have to comply to its terms, otherwise they have to buy a commercial license. The Open Source license is the GNU General Public License (GPL). Below is a brief overview of the license scheme and the rights given to users.","title":"Licensing"},{"location":"license/#open-source-license","text":"The code is released under the GPL in order to protect its commercial value. This allows for commercialisation, which guarantees long term support, maintenance and further developments of the code for the benefit of the project and its users. GPL primer GPL (v3+) is an Open Source license that, gives you the right to use, copy and modify the code freely. If you distribute your software based on GPL (i.e. without purchasing the commercial license), then the following applies You are obliged to distribute the modifications of MCUT you made, and You are furthermore obliged to distribute the source code of your own software under the GPL.","title":"Open source license"},{"location":"license/#commercial-license","text":"In cases where the constraints of the Open source license prevent you from using MCUT, you can buy a commercial license. The commercial license includes the full source code for MCUT and any associated tools, ongoing technical support, and all future updates at no additional cost. The commercial license also allows MCUT to be used in an unlimited number of products developed by a company. Email the author for further information.","title":"Commercial license"},{"location":"license/#philosophy","text":"The licensing model of MCUT is motivated by the desire to eliminate the access costs for users/creators of derivative works by minimising the restrictions posed by strict copyright rules. \u201cAccess costs\u201d refers to expenses for users that wish to e.g. do research or create a derivative work\u2014such as their own 3D mesh processing tool(s), a copy of MCUT modified to fix a bug, or add a feature\u2014but are unable (or perhaps even unwilling) to pay for the right to do so. This reduction of access costs also aims to increase usage by gaining \u201cmarket share\u201d, leading to even more frequent creation of derivative works. The by-product of this increased usage is further awareness e.g. through recommendations via networks, forums, word-of-mouth etc. The openness of MCUT\u00b4s development and its diverse user-base will also garner additional trust as a reliable tool that is also viable for commercial use. Being open also creates enormous value. For example, in the context of scientific research, MCUT\u00b4s functionality is shared for free and anyone with access to the source code can generate data (e.g. meshes, performance stats etc), develop simulations, and prototype geometry processing ideas amongst others. The original project may also receive feedback and potential improvements on the original design from the user community.","title":"Philosophy"},{"location":"product/","text":"The product \u00b6 MCUT is distributed as a cross-platform software library (static or shared) exposing a classic C API which can be used in practically any C++ application. The primary function of MCUT is to take two meshes, resolve their intersection(s) and generate fragment pieces of the sliced shape. When a mesh is cut, your application simply invokes a dispatch call. The MCUT API can then be queried for the desired output, like the patches that were used for hole-filling etc. MCUT cuts with any 2-manifold surface. This has the advantages that it easy to slice a multitude of shapes - from using simple surfaces like quads to performing complex CSG operations using meshes of arbitrary shape. Furthermore, the cut mesh (your knife tool) does not depend on the complexity of the source mesh, thus alleviating numerous impinging constrants on what you can do with MCUT. The gist about how MCUT works are discussed in a Journal article which you can find here here . Armadillo sliced with planer cut.","title":"The product"},{"location":"product/#the-product","text":"MCUT is distributed as a cross-platform software library (static or shared) exposing a classic C API which can be used in practically any C++ application. The primary function of MCUT is to take two meshes, resolve their intersection(s) and generate fragment pieces of the sliced shape. When a mesh is cut, your application simply invokes a dispatch call. The MCUT API can then be queried for the desired output, like the patches that were used for hole-filling etc. MCUT cuts with any 2-manifold surface. This has the advantages that it easy to slice a multitude of shapes - from using simple surfaces like quads to performing complex CSG operations using meshes of arbitrary shape. Furthermore, the cut mesh (your knife tool) does not depend on the complexity of the source mesh, thus alleviating numerous impinging constrants on what you can do with MCUT. The gist about how MCUT works are discussed in a Journal article which you can find here here . Armadillo sliced with planer cut.","title":"The product"},{"location":"tutorials/connectedComponents/","text":"Connected components \u00b6 TODO","title":"Connected components"},{"location":"tutorials/connectedComponents/#connected-components","text":"TODO","title":"Connected components"},{"location":"tutorials/contextInfo/","text":"Obtaining information about context state \u00b6 MCUT uses several opaque data structures whose properties can be examined with functions named mcGetXX . Context objects are no exception. The mcGetInfo function provides information about a context object\u2019s state, and its signature is as follows McResult mcGetInfo ( const McContext context , McFlags info , uint64_t bytes , void * pMem , uint64_t * pNumBytes ); These arguments are straightforward. The first three provide input: the context object, a name that identifies the type of data you\u2019re requesting, and the amount of data you\u2019re requesting. The last two arguments are output arguments, in which the function returns the data you\u2019re requesting and the size of the returned data. The data type of the fourth argument is dependant on the second argument. The second argument is an enumerated type that can take any of the values in the following table: Parameter name Parameter value Purpose MC_CONTEXT_FLAGS McFlags Returns a bitfield encoding the flags used to create the context. MC_DEFAULT_PRECISION uint64_t Default number of bits used to represent the significand of a floating-point number. MC_DEFAULT_ROUNDING_MODE McRoundingModeFlags Default way to round the result of a floating-point operation. MC_PRECISION_MAX uint64_t Maximum value for precision bits. MC_PRECISION_MIN uint64_t Minimum value for precision bits. Here is an example of how to use the mcGetInfo function: McFlags defaultRoundingMode = 0 ; uint64_t numBytes = 0 ; McResult err = mcGetInfo ( context , MC_DEFAULT_ROUNDING_MODE , 0 , nullptr , & numBytes ); if ( err ) { // ... } err = mcGetInfo ( context , MC_DEFAULT_ROUNDING_MODE , numBytes , & defaultRoundingMode , nullptr ); if ( err ) { // ... } std :: fprintf ( stdout , \"default precision: %\" PRId64 \" \\n \" , ( uint64_t ) defaultPrec ); If MCUT has not been compiled with arbitrary-precision numbers, then information dependant on MC_DEFAULT_PRECISION , MC_PRECISION_MAX and MC_PRECISION_MIN should not be relied on.","title":"Obtaining information about context state"},{"location":"tutorials/contextInfo/#obtaining-information-about-context-state","text":"MCUT uses several opaque data structures whose properties can be examined with functions named mcGetXX . Context objects are no exception. The mcGetInfo function provides information about a context object\u2019s state, and its signature is as follows McResult mcGetInfo ( const McContext context , McFlags info , uint64_t bytes , void * pMem , uint64_t * pNumBytes ); These arguments are straightforward. The first three provide input: the context object, a name that identifies the type of data you\u2019re requesting, and the amount of data you\u2019re requesting. The last two arguments are output arguments, in which the function returns the data you\u2019re requesting and the size of the returned data. The data type of the fourth argument is dependant on the second argument. The second argument is an enumerated type that can take any of the values in the following table: Parameter name Parameter value Purpose MC_CONTEXT_FLAGS McFlags Returns a bitfield encoding the flags used to create the context. MC_DEFAULT_PRECISION uint64_t Default number of bits used to represent the significand of a floating-point number. MC_DEFAULT_ROUNDING_MODE McRoundingModeFlags Default way to round the result of a floating-point operation. MC_PRECISION_MAX uint64_t Maximum value for precision bits. MC_PRECISION_MIN uint64_t Minimum value for precision bits. Here is an example of how to use the mcGetInfo function: McFlags defaultRoundingMode = 0 ; uint64_t numBytes = 0 ; McResult err = mcGetInfo ( context , MC_DEFAULT_ROUNDING_MODE , 0 , nullptr , & numBytes ); if ( err ) { // ... } err = mcGetInfo ( context , MC_DEFAULT_ROUNDING_MODE , numBytes , & defaultRoundingMode , nullptr ); if ( err ) { // ... } std :: fprintf ( stdout , \"default precision: %\" PRId64 \" \\n \" , ( uint64_t ) defaultPrec ); If MCUT has not been compiled with arbitrary-precision numbers, then information dependant on MC_DEFAULT_PRECISION , MC_PRECISION_MAX and MC_PRECISION_MIN should not be relied on.","title":"Obtaining information about context state"},{"location":"tutorials/debugging/","text":"Debugging \u00b6 Using MCUT can be a lot of fun, but it may also be a source of frustration whenever something isn\u2019t working just right! Since most of what you will do involves working with geometry, it may be difficult to figure out the source of an error whenever something does not work as expected. In this tutorial we look into several ways of debugging your MCUT program. Error codes \u00b6 All MCUT API functions return an error code. The error codes that functions can return are listed below: Flag Description MC_NO_ERROR Everthing is fine. MC_INVALID_OPERATION The state for a command is not legal for its given parameters. MC_INVALID_VALUE Set when a value parameter is not legal. MC_OUT_OF_MEMORY Internal memory allocation failure. Within MCUT\u2019s function documentation you can always find the error codes a function generates the moment it is incorrectly used. The great thing about returned error codes is that they makes it relatively easy to pinpoint where any error may be and to validate the proper use of MCUT. Let\u2019s say you query zero connected components after an mcDispatch call and you have no idea what\u2019s causing it: did the meshes intersect? Where the input meshes valid? By checking returned error flag all over your codebase, you can quickly catch the first place an MCUT error starts showing up. Helper functions \u00b6 The returned error codes are just numbers, which isn\u2019t easy to understand unless you\u2019ve memorized the error codes. It often makes sense to write a small helper function to easily print out the error strings together with where the error check function was called: void mcCheckError_ ( McResult err , const char * file , int line ) { if ( err != MC_NO_ERROR ){ std :: string errorStr ; switch ( err ) { case MC_INVALID_OPERATION : errorStr = \"MC_INVALID_OPERATION\" ; break ; // ... } std :: cout << errorStr << \" | \" << file << \" (\" << line << \")\" << std :: endl ; } } #define mcCheckError(errCode) mcCheckError_(errCode, __FILE__, __LINE__) We can then use this function as follows: // make some API call and return error code McResult err = mcGetConnectedComponents ( context , MC_CONNECTED_COMPONENT_TYPE_ALL , 0 , NULL , & numConnComps ); // ... now check the error code mcCheckError ( err ); Debug output \u00b6 Helper functions are useful, but return codes alone can\u2019t help too much because information that functions will return is rather simple. However, it does often help you catch typos or quickly pinpoint where things went wrong. A more comprehensive tool is the debug output feature. With the debug output, MCUT will directly send an error or warning message to the user with a lot more details compared to returned codes. Not only does it provide more information, it can also help you catch errors exactly where they occur by intelligently using a debugger. To start using debug output we have to setup a debug context . This step is a matter of specifying a flag: McContext context = MC_NULL_HANDLE ; McResult err = mcCreateContext ( & context , MC_DEBUG ); if ( err ) { // ... } To check if we successfully initialized a debug context we can query MCUT as follows: uint64_t numBytes = 0 ; McFlags contextFlags ; McResult err = mcGetInfo ( context , MC_CONTEXT_FLAGS , 0 , nullptr , & numBytes ); if ( err ) { // ... } err = mcGetInfo ( context , MC_CONTEXT_FLAGS , numBytes , & contextFlags , nullptr ); if ( err ) { // ... } if ( contextFlags & MC_DEBUG ) { // do stuff with our debug context... } The way debug output works is that we pass MCUT an error logging callback function . This callback function will be used to process the MCUT error data as we wish. For this particular example, we\u2019ll be displaying useful error data to the console. Here is the callback function prototype that MCUT expects for debug output: void MCAPI_CALL ( * pfn_mcDebugOutput_CALLBACK )( McDebugSource source , McDebugType type , uint32_t id , McDebugSeverity severity , size_t length , const char * message , const void * userParam ); We can then create a useful error printing utility function like this: extern MCAPI_ATTR void MCAPI_CALL mcDebugOutput ( McDebugSource source , McDebugType type , unsigned int id , McDebugSeverity severity , size_t length , const char * message , const void * userParam ) { printf ( \"--------------- \\n \" ); printf ( \"Debug message ( %d ): %s \" , id , message ); switch ( source ) { case MC_DEBUG_SOURCE_API : printf ( \"Source: API\" ); break ; case MC_DEBUG_SOURCE_KERNEL : printf ( \"Source: Kernel\" ); break ; break ; } printf ( \" \\n \" ); switch ( type ) { case MC_DEBUG_TYPE_ERROR : printf ( \"Type: Error\" ); break ; case MC_DEBUG_TYPE_DEPRECATED_BEHAVIOR : printf ( \"Type: Deprecated Behaviour\" ); break ; case MC_DEBUG_TYPE_OTHER : printf ( \"Type: Other\" ); break ; } printf ( \" \\n \" ); switch ( severity ) { case MC_DEBUG_SEVERITY_HIGH : printf ( \"Severity: high\" ); break ; case MC_DEBUG_SEVERITY_MIDIUM : printf ( \"Severity: medium\" ); break ; case MC_DEBUG_SEVERITY_LOW : printf ( \"Severity: low\" ); break ; case MC_DEBUG_SEVERITY_NOTIFICATION : printf ( \"Severity: notification\" ); break ; } printf ( \" \\n\\n \" ); } Whenever debug output detects an MCUT error, it will call this callback function and we\u2019ll be able to print out a large deal of information regarding the MCUT error. Now that we have the callback function, the next step is to initialize debug output: if ( contextFlags & MC_DEBUG ) { mcDebugMessageCallback ( context , mcDebugOutput , nullptr ); mcDebugMessageControl ( context , MC_DEBUG_SOURCE_ALL , MC_DEBUG_TYPE_ALL , MC_DEBUG_SEVERITY_ALL , true ); } Filtering debug output \u00b6 With mcDebugMessageControl you can filter the type(s) of errors you\u2019d like to receive a message from. In our case we decided to not filter on any of the sources, types, or severity rates. If we wanted to only show messages from the MCUT API, that are errors, and have a high severity, we\u2019d configure it as follows: mcDebugMessageControl ( context , MC_DEBUG_SOURCE_API , MC_DEBUG_TYPE_ERROR , MC_DEBUG_SEVERITY_HIGH , true ); Given our configuration, and assuming you have a context that supports debug output, every incorrect MCUT command will now print a bunch of potentially useful data. Backtracking the debug error source Another great trick with debug output is that you can relatively easily figure out the exact line or call an error occurred. By setting a breakpoint in mcDebugOutput at a specific error type (or at the top of the function if you don\u2019t care), the debugger will catch the error thrown and you can move up the call stack to whatever function caused the message dispatch.","title":"Debugging"},{"location":"tutorials/debugging/#debugging","text":"Using MCUT can be a lot of fun, but it may also be a source of frustration whenever something isn\u2019t working just right! Since most of what you will do involves working with geometry, it may be difficult to figure out the source of an error whenever something does not work as expected. In this tutorial we look into several ways of debugging your MCUT program.","title":"Debugging"},{"location":"tutorials/debugging/#error-codes","text":"All MCUT API functions return an error code. The error codes that functions can return are listed below: Flag Description MC_NO_ERROR Everthing is fine. MC_INVALID_OPERATION The state for a command is not legal for its given parameters. MC_INVALID_VALUE Set when a value parameter is not legal. MC_OUT_OF_MEMORY Internal memory allocation failure. Within MCUT\u2019s function documentation you can always find the error codes a function generates the moment it is incorrectly used. The great thing about returned error codes is that they makes it relatively easy to pinpoint where any error may be and to validate the proper use of MCUT. Let\u2019s say you query zero connected components after an mcDispatch call and you have no idea what\u2019s causing it: did the meshes intersect? Where the input meshes valid? By checking returned error flag all over your codebase, you can quickly catch the first place an MCUT error starts showing up.","title":"Error codes"},{"location":"tutorials/debugging/#helper-functions","text":"The returned error codes are just numbers, which isn\u2019t easy to understand unless you\u2019ve memorized the error codes. It often makes sense to write a small helper function to easily print out the error strings together with where the error check function was called: void mcCheckError_ ( McResult err , const char * file , int line ) { if ( err != MC_NO_ERROR ){ std :: string errorStr ; switch ( err ) { case MC_INVALID_OPERATION : errorStr = \"MC_INVALID_OPERATION\" ; break ; // ... } std :: cout << errorStr << \" | \" << file << \" (\" << line << \")\" << std :: endl ; } } #define mcCheckError(errCode) mcCheckError_(errCode, __FILE__, __LINE__) We can then use this function as follows: // make some API call and return error code McResult err = mcGetConnectedComponents ( context , MC_CONNECTED_COMPONENT_TYPE_ALL , 0 , NULL , & numConnComps ); // ... now check the error code mcCheckError ( err );","title":"Helper functions"},{"location":"tutorials/debugging/#debug-output","text":"Helper functions are useful, but return codes alone can\u2019t help too much because information that functions will return is rather simple. However, it does often help you catch typos or quickly pinpoint where things went wrong. A more comprehensive tool is the debug output feature. With the debug output, MCUT will directly send an error or warning message to the user with a lot more details compared to returned codes. Not only does it provide more information, it can also help you catch errors exactly where they occur by intelligently using a debugger. To start using debug output we have to setup a debug context . This step is a matter of specifying a flag: McContext context = MC_NULL_HANDLE ; McResult err = mcCreateContext ( & context , MC_DEBUG ); if ( err ) { // ... } To check if we successfully initialized a debug context we can query MCUT as follows: uint64_t numBytes = 0 ; McFlags contextFlags ; McResult err = mcGetInfo ( context , MC_CONTEXT_FLAGS , 0 , nullptr , & numBytes ); if ( err ) { // ... } err = mcGetInfo ( context , MC_CONTEXT_FLAGS , numBytes , & contextFlags , nullptr ); if ( err ) { // ... } if ( contextFlags & MC_DEBUG ) { // do stuff with our debug context... } The way debug output works is that we pass MCUT an error logging callback function . This callback function will be used to process the MCUT error data as we wish. For this particular example, we\u2019ll be displaying useful error data to the console. Here is the callback function prototype that MCUT expects for debug output: void MCAPI_CALL ( * pfn_mcDebugOutput_CALLBACK )( McDebugSource source , McDebugType type , uint32_t id , McDebugSeverity severity , size_t length , const char * message , const void * userParam ); We can then create a useful error printing utility function like this: extern MCAPI_ATTR void MCAPI_CALL mcDebugOutput ( McDebugSource source , McDebugType type , unsigned int id , McDebugSeverity severity , size_t length , const char * message , const void * userParam ) { printf ( \"--------------- \\n \" ); printf ( \"Debug message ( %d ): %s \" , id , message ); switch ( source ) { case MC_DEBUG_SOURCE_API : printf ( \"Source: API\" ); break ; case MC_DEBUG_SOURCE_KERNEL : printf ( \"Source: Kernel\" ); break ; break ; } printf ( \" \\n \" ); switch ( type ) { case MC_DEBUG_TYPE_ERROR : printf ( \"Type: Error\" ); break ; case MC_DEBUG_TYPE_DEPRECATED_BEHAVIOR : printf ( \"Type: Deprecated Behaviour\" ); break ; case MC_DEBUG_TYPE_OTHER : printf ( \"Type: Other\" ); break ; } printf ( \" \\n \" ); switch ( severity ) { case MC_DEBUG_SEVERITY_HIGH : printf ( \"Severity: high\" ); break ; case MC_DEBUG_SEVERITY_MIDIUM : printf ( \"Severity: medium\" ); break ; case MC_DEBUG_SEVERITY_LOW : printf ( \"Severity: low\" ); break ; case MC_DEBUG_SEVERITY_NOTIFICATION : printf ( \"Severity: notification\" ); break ; } printf ( \" \\n\\n \" ); } Whenever debug output detects an MCUT error, it will call this callback function and we\u2019ll be able to print out a large deal of information regarding the MCUT error. Now that we have the callback function, the next step is to initialize debug output: if ( contextFlags & MC_DEBUG ) { mcDebugMessageCallback ( context , mcDebugOutput , nullptr ); mcDebugMessageControl ( context , MC_DEBUG_SOURCE_ALL , MC_DEBUG_TYPE_ALL , MC_DEBUG_SEVERITY_ALL , true ); }","title":"Debug output"},{"location":"tutorials/debugging/#filtering-debug-output","text":"With mcDebugMessageControl you can filter the type(s) of errors you\u2019d like to receive a message from. In our case we decided to not filter on any of the sources, types, or severity rates. If we wanted to only show messages from the MCUT API, that are errors, and have a high severity, we\u2019d configure it as follows: mcDebugMessageControl ( context , MC_DEBUG_SOURCE_API , MC_DEBUG_TYPE_ERROR , MC_DEBUG_SEVERITY_HIGH , true ); Given our configuration, and assuming you have a context that supports debug output, every incorrect MCUT command will now print a bunch of potentially useful data. Backtracking the debug error source Another great trick with debug output is that you can relatively easily figure out the exact line or call an error occurred. By setting a breakpoint in mcDebugOutput at a specific error type (or at the top of the function if you don\u2019t care), the debugger will catch the error thrown and you can move up the call stack to whatever function caused the message dispatch.","title":"Filtering debug output"},{"location":"tutorials/designPrincipals/","text":"Design principles \u00b6 Here we summarize the design principles of MCUT: Fast : Processing meshes with over 100k polygons in a few seconds. Robust : Thorougly tested and works with exact predicates. Simple : Straightforward and portable C-API. Minimal : Self-contained and without dependancies. The above image depicts the gist of what MCUT does. On the left is a cube (the \u201csource mesh\u201d) that is cut by a circular surface (the \u201ccut mesh\u201d), which together comprise the input . On the right is the resulting set of connected components after partitioning the cube. In general, the output of MCUT includes unsealed fragments (mid-left), cut mesh patches (middle), and the sealed fragments whose holes have been filled with cut mesh polygons that lie on the interior of the source mesh. Sealing can also be done using cut mesh polygons that lie on the exterior of the source mesh.","title":"Design principles"},{"location":"tutorials/designPrincipals/#design-principles","text":"Here we summarize the design principles of MCUT: Fast : Processing meshes with over 100k polygons in a few seconds. Robust : Thorougly tested and works with exact predicates. Simple : Straightforward and portable C-API. Minimal : Self-contained and without dependancies. The above image depicts the gist of what MCUT does. On the left is a cube (the \u201csource mesh\u201d) that is cut by a circular surface (the \u201ccut mesh\u201d), which together comprise the input . On the right is the resulting set of connected components after partitioning the cube. In general, the output of MCUT includes unsealed fragments (mid-left), cut mesh patches (middle), and the sealed fragments whose holes have been filled with cut mesh polygons that lie on the interior of the source mesh. Sealing can also be done using cut mesh polygons that lie on the exterior of the source mesh.","title":"Design principles"},{"location":"tutorials/exactCoords/","text":"Querying exact coordinates \u00b6 As described in the meshes tutorial , mesh vertices that are represented using arbitrary precision will be specified using character strings (i.e. as const char* ). A single string specifies the coordinates as a space-separated sequence of real numbers. (Tuples of three numbers are also possible, placing newline character in place of every third space character). With this format, this tutorial shows how to query/ask MCUT for vertex coordinates as a character string representing their exact values. The first step is querying the actual number of vertices (in a given connected component). We must explicitly query the number of vertices because this information cannot be inferred from the number of bytes - unlike double and float . uint64_t vertexCountBytes = 0 ; McResult err = mcGetConnectedComponentData ( context , cc , // given connected component MC_CONNECTED_COMPONENT_DATA_VERTEX_COUNT , 0 , NULL , & vertexCountBytes ); if ( err ) { // ... } // It possible to also directly query the number of vertices // since we know the number of bytes, which is a constant 4 bytes! uint32_t numberOfVertices = 0 ; McResult err = mcGetConnectedComponentData ( context_ , cc , MC_CONNECTED_COMPONENT_DATA_VERTEX_COUNT , vertexCountBytes , & numberOfVertices , NULL ); if ( err ) { // ... } Once we know the number of vertices, the next step is querying the exact coordinates which we do as follows: uint64_t connCompVerticesBytes = 0 ; McResult err = mcGetConnectedComponentData ( context_ , cc , MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT , 0 , NULL , & connCompVerticesBytes ); if ( err ) { // ... } std :: vector < char > rawVerticesString ; rawVerticesString . resize ( connCompVerticesBytes ); McResult err = mcGetConnectedComponentData ( context_ , cc , MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT , connCompVerticesBytes , ( void * ) rawVerticesString . data (), NULL ); if ( err ) { // ... } auto isPartOfDigit = [ & ]( unsigned char ch ) { return ch == '.' || ch == '-' || std :: isdigit ( ch ); }; std :: vector < char > x ; std :: vector < char > y ; std :: vector < char > z ; const char * vptr = reinterpret_cast < const char *> ( rawVerticesString . data ()); const char * vptr_ = vptr ; // shifted // for each number ... for ( uint32_t i = 0 ; i < numberOfVertices * 3 ; ++ i ) { vptr_ = std :: strchr ( vptr , ' ' ); // find next space // length of string representing a number (very long!) std :: ptrdiff_t diff = vptr_ - vptr ; uint64_t srcStrLen = diff + 1 ; // extra byte for null-char if ( vptr_ == nullptr ) { srcStrLen = std :: strlen ( vptr ) + 1 ; } if (( i % 3 ) == 0 ) { // x coord x . resize ( srcStrLen ); std :: sscanf ( vptr , \"%s\" , & x [ 0 ]); x . back () = '\\0' ; if ( ! isPartOfDigit ( x [ 0 ])) { // ... } } else if (( i % 3 ) - 1 == 0 ) { // y coord y . resize ( srcStrLen ); std :: sscanf ( vptr , \"%s\" , & y [ 0 ]); y . back () = '\\0' ; if ( ! isPartOfDigit ( y [ 0 ])) { // ... } } else if (( i % 3 ) - 2 == 0 ) { // z coord z . resize ( srcStrLen ); std :: sscanf ( vptr , \"%s\" , & z [ 0 ]); z . back () = '\\0' ; if ( ! isPartOfDigit ( z [ 0 ])) { // ... } } vptr = vptr_ + 1 ; // offset so that we point to the start of the next number/line } Note that using MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT guarrantees exact numbers only if the following is true mcDispatch was called with meshes defined using MC_DISPATCH_VERTEX_ARRAY_EXACT , and MCUT libary is implemented with arbitrary precision numbers enabled (see Compilation ). Otherwise, the operation is equivalent to using std::to_string on values of type float or double , respectively.","title":"Querying exact coordinates"},{"location":"tutorials/exactCoords/#querying-exact-coordinates","text":"As described in the meshes tutorial , mesh vertices that are represented using arbitrary precision will be specified using character strings (i.e. as const char* ). A single string specifies the coordinates as a space-separated sequence of real numbers. (Tuples of three numbers are also possible, placing newline character in place of every third space character). With this format, this tutorial shows how to query/ask MCUT for vertex coordinates as a character string representing their exact values. The first step is querying the actual number of vertices (in a given connected component). We must explicitly query the number of vertices because this information cannot be inferred from the number of bytes - unlike double and float . uint64_t vertexCountBytes = 0 ; McResult err = mcGetConnectedComponentData ( context , cc , // given connected component MC_CONNECTED_COMPONENT_DATA_VERTEX_COUNT , 0 , NULL , & vertexCountBytes ); if ( err ) { // ... } // It possible to also directly query the number of vertices // since we know the number of bytes, which is a constant 4 bytes! uint32_t numberOfVertices = 0 ; McResult err = mcGetConnectedComponentData ( context_ , cc , MC_CONNECTED_COMPONENT_DATA_VERTEX_COUNT , vertexCountBytes , & numberOfVertices , NULL ); if ( err ) { // ... } Once we know the number of vertices, the next step is querying the exact coordinates which we do as follows: uint64_t connCompVerticesBytes = 0 ; McResult err = mcGetConnectedComponentData ( context_ , cc , MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT , 0 , NULL , & connCompVerticesBytes ); if ( err ) { // ... } std :: vector < char > rawVerticesString ; rawVerticesString . resize ( connCompVerticesBytes ); McResult err = mcGetConnectedComponentData ( context_ , cc , MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT , connCompVerticesBytes , ( void * ) rawVerticesString . data (), NULL ); if ( err ) { // ... } auto isPartOfDigit = [ & ]( unsigned char ch ) { return ch == '.' || ch == '-' || std :: isdigit ( ch ); }; std :: vector < char > x ; std :: vector < char > y ; std :: vector < char > z ; const char * vptr = reinterpret_cast < const char *> ( rawVerticesString . data ()); const char * vptr_ = vptr ; // shifted // for each number ... for ( uint32_t i = 0 ; i < numberOfVertices * 3 ; ++ i ) { vptr_ = std :: strchr ( vptr , ' ' ); // find next space // length of string representing a number (very long!) std :: ptrdiff_t diff = vptr_ - vptr ; uint64_t srcStrLen = diff + 1 ; // extra byte for null-char if ( vptr_ == nullptr ) { srcStrLen = std :: strlen ( vptr ) + 1 ; } if (( i % 3 ) == 0 ) { // x coord x . resize ( srcStrLen ); std :: sscanf ( vptr , \"%s\" , & x [ 0 ]); x . back () = '\\0' ; if ( ! isPartOfDigit ( x [ 0 ])) { // ... } } else if (( i % 3 ) - 1 == 0 ) { // y coord y . resize ( srcStrLen ); std :: sscanf ( vptr , \"%s\" , & y [ 0 ]); y . back () = '\\0' ; if ( ! isPartOfDigit ( y [ 0 ])) { // ... } } else if (( i % 3 ) - 2 == 0 ) { // z coord z . resize ( srcStrLen ); std :: sscanf ( vptr , \"%s\" , & z [ 0 ]); z . back () = '\\0' ; if ( ! isPartOfDigit ( z [ 0 ])) { // ... } } vptr = vptr_ + 1 ; // offset so that we point to the start of the next number/line } Note that using MC_CONNECTED_COMPONENT_DATA_VERTEX_EXACT guarrantees exact numbers only if the following is true mcDispatch was called with meshes defined using MC_DISPATCH_VERTEX_ARRAY_EXACT , and MCUT libary is implemented with arbitrary precision numbers enabled (see Compilation ). Otherwise, the operation is equivalent to using std::to_string on values of type float or double , respectively.","title":"Querying exact coordinates"},{"location":"tutorials/helloWorld/","text":"Hello MCUT world \u00b6 In this tutorial, we will look at simple HelloWorld-style example of an MCUT application. The purpose of the tutorial is to get you up to speed with using MCUT for cutting arbitrary meshes. Input meshes \u00b6 The first thing we will do is define our meshes, which are the source mesh and cut mesh. This section, describes how we define these meshes. The source mesh \u00b6 Here we will now define the source mesh, which will be cube as shown in the image below. The source mesh: a cube. float cubeVertices [] = { -5 , -5 , 5 , // 0 5 , -5 , 5 , // 1 5 , 5 , 5 , //2 -5 , 5 , 5 , //3 -5 , -5 , -5 , //4 5 , -5 , -5 , //5 5 , 5 , -5 , //6 -5 , 5 , -5 //7 }; uint32_t cubeFaces [] = { 0 , 1 , 2 , 3 , //0 7 , 6 , 5 , 4 , //1 1 , 5 , 6 , 2 , //2 0 , 3 , 7 , 4 , //3 3 , 2 , 6 , 7 , //4 4 , 5 , 1 , 0 //5 }; uint32_t cubeFaceSizes [] = { 4 , 4 , 4 , 4 , 4 , 4 }; uint32_t numCubeVertices = 8 ; uint32_t numCubeFaces = 6 ; As you see, we just use simple C-style arrays to define the geometry and connectivity of our cube. This is all that MCUT needs to define a mesh: a list of vertices a list faces (indices) a list of face sizes (a value for each face) the number of vertices the number of faces The cut mesh \u00b6 Now that we have defined our source mesh, lets define the cut mesh. This will be the object that we will be slicing our cube with. Here is what the cut mesh looks like, and the code for defining this mesh is provided just below too. The cut mesh: a quad bent in the middle. float cutMeshVertices [] = { -20 , -4 , 0 , //0 0 , 20 , 20 , //1 20 , -4 , 0 , //2 0 , 20 , -20 //3 }; uint32_t cutMeshFaces [] = { 0 , 1 , 2 , //0 0 , 2 , 3 //1 }; uint32_t cutMeshFaceSizes [] = { 3 , 3 }; uint32_t numCutMeshVertices = 4 ; uint32_t numCutMeshFaces = 2 ; Again, the data structures for defining our cut mesh are exactly the same as the source mesh. All we did was just change the data - simple. Visualising mesh placement \u00b6 Before we proceed onto actually calling any MCUT functions, here is a visual depiction of the relative placement of the two meshes: A combined visualisation of our meshes, using their unmodified vertex coordinates. This relative positioning is determined by our vertex coordinates - as specified when we defined the meshes. Using the MCUT API \u00b6 Up to now, we have described how to define meshes in a suitable format for MCUT to read. This is the first step of using MCUT - actually defining the mesh data to use for cutting. In this section, we will now describe how to cut our cube mesh with the cut mesh using MCUT. Creating a context \u00b6 First things first, we must create a context. MCUT contexts are represented by McContext data structures, and you can create them using: McContext context = MC_NULL_HANDLE ; mcCreateContext ( & context , MC_NULL_HANDLE ); MCUT uses the allocated context object to handle state, memory resources, etc. We can also think of mcCreateContext like the \u2018init\u2019 function (kinda\u2026). And thats pretty much it - thats all we need to do in order to \u201cinitialize\u201d MCUT before we can do the fun stuff . Lets do some cutting. The dispatch call \u00b6 Now that we have our mesh data and a context has been created, the next step is cut the cube. To do this, we call the mcDispatch function like this: mcDispatch ( context , MC_DISPATCH_VERTEX_ARRAY_FLOAT , cubeVertices , cubeFaces , cubeFaceSizes , numCubeVertices , numCubeFaces , cutMeshVertices , cutMeshFaces , cutMeshFaceSizes , numCutMeshVertices , numCutMeshFaces ); \u2026 and that\u2019s it - we have cut our cube. Simple huh..? Before moving on to the next section, let peek at the parameters a bit. They seem a lot at-first-glance but if we look closer we can see that most of them are just our mesh variables that we defined previously. So they are covered. The first parameter is our context (of-course!) which will hold all information/state relating to our operation. The second parameter specifies how MCUT should interpret our vertex arrays ( cubeVertices and cutMeshVertices ). In this example, MC_DISPATCH_VERTEX_ARRAY_FLOAT means \u201cinterpret the data as 32-bit floats\u201d which must match with our arrays. Where\u2019s my output? \u00b6 At this point, MCUT has cut the cube, which was done by calling using the mcDispatch function. However, there\u2019s no evidence of output meshes anywhere in our code which we need to show that MCUT actually did something! So in this section, we will find out how to ask MCUT to give us the result(s) of the cutting operation that we just performed. How many meshes? \u00b6 The first step to getting our output from MCUT to query for how many meshes (otherwise known as \u201cconnected components\u201d) of a particular type are available. Since we are learning about what MCUT can do, we will request all of the output that resulted from our cube being cut. Here\u2019s how we do that: uint32_t numConnComps ; std :: vector < McConnectedComponent > connComps ; mcGetConnectedComponents ( context , MC_CONNECTED_COMPONENT_TYPE_ALL , 0 , NULL , & numConnComps ); connComps . resize ( numConnComps ); mcGetConnectedComponents ( context , MC_CONNECTED_COMPONENT_TYPE_ALL , ( uint32_t ) connComps . size (), connComps . data (), NULL ); Notice how we had to call mcGetConnectedComponents twice? We do this because in MCUT querying information is a two-step process. First you need to allocate memory for one or more structures. Then you need to initialize these structures. The code above calls mcGetConnectedComponents twice. The first time, it places the number of connected components in the numConnComps variable. The second time, it places McConnectedComponent structures in the connComps array. We\u2019ll employ this function-allocation-function procedure for many other types of queries as well. Notice that we also provided the parameter MC_CONNECTED_COMPONENT_TYPE_ALL which specifies that we want all connected components from MCUT. This allows for filtering to get just the connected components we want by specifying different values. Accessing mesh data \u00b6 Once we\u2019ve accessed an available connected component, we can access every type of data that we can query for one - like its vertices. In code, connected components (i.e. meshes) are represented by McConnectedComponent structures. These are easy to work with, and the functions that relate to connected component data are very similar to mcGetConnectedComponents from the preceding section. This section presents the another MCUT connected component function, mcGetConnectedComponentData , and shows how it is used in code. As its name implies, mcGetConnectedComponentData accepts a McConnectedComponent (amongst others) and provides information about the corresponding connected component. This operates in exactly the same way that mcGetConnectedComponents does: Identify the type of information you\u2019re looking for, and the function will place the data in the memory referenced. We will now show how to query connected componented data. Assume that these variables have been defined in the following snippets: McConnectedComponent connComp = connComps [ i ]; // connected component handle. uint64_t numBytes = 0 ; // number of bytes we must allocate. And here is how we query the data of a connected component (vertices, faces etc.): query the vertices mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_VERTEX_FLOAT , 0 , NULL , & numBytes ); std :: vector < float > vertices ; vertices . resize ( numBytes / sizeof ( float )); //... or --> numberOfVertices * 3 mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_VERTEX_FLOAT , numBytes , ( void * ) vertices . data (), NULL ); The number of vertices can be determined based on the type used to represent the queried vertices and the number of bytes: uint32_t numberOfVertices = numBytes / ( sizeof ( float ) * 3 ); // 3 floats per vertex query the faces mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE , 0 , NULL , & numBytes ); std :: vector < uint32_t > faceIndices ; faceIndices . resize ( numBytes / sizeof ( uint32_t )); mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE , numBytes , faceIndices . data (), NULL ); query the face sizes mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE_SIZE , 0 , NULL , & numBytes ); std :: vector < uint32_t > faceSizes ; faceSizes . resize ( numBytes / sizeof ( uint32_t )); mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE_SIZE , numBytes , faceSizes . data (), NULL ); Glancing through the code, its fairly easy to see that we are using mcGetConnectedComponentData similarly to the way we used mcGetConnectedComponents in the previous section, which makes the library very easy to use. We are done! So lets clean up before seeing our results and wrapping up below. Cleaning up \u00b6 Now that we have finished using MCUT, we must free all resources that were allocated for our connected components. Since we want to free all connected component data, we will just do: mcReleaseConnectedComponents ( context , 0 , NULL ); \u2026 which will release the resources held by the library for all connected components. Finally, we will also destroy our context since we will not be performing any further cutting operations. Here\u2019s how we do that: mcReleaseContext ( context ); Results \u00b6 In this section, we show the meshes produced as a result of cutting our cube with MCUT. Internally sealed fragments Here we show the canonical results of the cut, which are the two watertight fragments of our cube. We have effectively cut and filled the holes in our cube to produce the fragments. Internally-sealed lower fragment. Internally-sealed upper fragment. Externally sealed fragments Here we show an odd but unique case, which is an example of sealing our cube from the outside. Externally-sealed lower fragment. Externally-sealed upper fragment. Such a result is readily produced by MCUT, and is the cornerstone of MCUT\u2019s support of CSG (boolean) operations. As you may imagine, this feature enables new techniques and effects for mesh editing tools. Unsealed fragments In this example, we show that not only can MCUT produce watertight and externally sealed meshes, but that MCUT can also provide the unsealed fragments of the source mesh. It is also possible to retrieve partially sealed meshes which is not shown here. Unsealed lower fragment. Unsealed upper fragment. Patches While the focus is generally on the source much, the versatility MCUT also allows us to create cut-outs of the cut mesh. Interior patch. Exterior patch. We refer to this as stencilling . The left image show the interior patch of the cut surface, which can be used for emulating effects like \u201cgingerbread man\u201d style cut-outs. On the right, we show the exterior patch which likewise holds potential use-cases of its own. One example application, is producing silhouette cut-outs for simulating deformation or cloth-like effects on intricate geometries. Seams Finally, in this example we show that MCUT can also be used as a practical tool for computing intersection contours. These are the paths of intersection between the source mesh and cut mesh. Source mesh with added seam. Cut mesh with added seam. One example application of seams is global intersection analysis in character animation, which is the backbone of industry-standard collision-response algorithms for unoriented objects like cloth. A key point to note here is that this feature results directly from the generality of MCUT, resolving mesh intersections using the half-edge data structure. Summary \u00b6 In this tutorial, we have looked a simple HelloWorld-style of application using MCUT. First, mesh initialisation was described, showing that defining a mesh boils doing to simple C-style arrays. We then proceeded to create an MCUT context, which allowed us to submit a dispatch call to do the cutting. We demonstrated that all of these steps were brief and simple. Next, we delved into the task of querying data from MCUT after a dispatch call. In this regard, we found out how MCUT uses a \u201cfunction-allocation-function procedure\u201d to query information. This was then used to access connected components (our meshes), and their data (vertices, face indices etc.). Finally, we finished off by showing how to free internal memory allocated by the MCUT library, and then topped off with some nice visualisations of the output meshes.","title":"HelloWorld"},{"location":"tutorials/helloWorld/#hello-mcut-world","text":"In this tutorial, we will look at simple HelloWorld-style example of an MCUT application. The purpose of the tutorial is to get you up to speed with using MCUT for cutting arbitrary meshes.","title":"Hello MCUT world"},{"location":"tutorials/helloWorld/#input-meshes","text":"The first thing we will do is define our meshes, which are the source mesh and cut mesh. This section, describes how we define these meshes.","title":"Input meshes"},{"location":"tutorials/helloWorld/#the-source-mesh","text":"Here we will now define the source mesh, which will be cube as shown in the image below. The source mesh: a cube. float cubeVertices [] = { -5 , -5 , 5 , // 0 5 , -5 , 5 , // 1 5 , 5 , 5 , //2 -5 , 5 , 5 , //3 -5 , -5 , -5 , //4 5 , -5 , -5 , //5 5 , 5 , -5 , //6 -5 , 5 , -5 //7 }; uint32_t cubeFaces [] = { 0 , 1 , 2 , 3 , //0 7 , 6 , 5 , 4 , //1 1 , 5 , 6 , 2 , //2 0 , 3 , 7 , 4 , //3 3 , 2 , 6 , 7 , //4 4 , 5 , 1 , 0 //5 }; uint32_t cubeFaceSizes [] = { 4 , 4 , 4 , 4 , 4 , 4 }; uint32_t numCubeVertices = 8 ; uint32_t numCubeFaces = 6 ; As you see, we just use simple C-style arrays to define the geometry and connectivity of our cube. This is all that MCUT needs to define a mesh: a list of vertices a list faces (indices) a list of face sizes (a value for each face) the number of vertices the number of faces","title":"The source mesh"},{"location":"tutorials/helloWorld/#the-cut-mesh","text":"Now that we have defined our source mesh, lets define the cut mesh. This will be the object that we will be slicing our cube with. Here is what the cut mesh looks like, and the code for defining this mesh is provided just below too. The cut mesh: a quad bent in the middle. float cutMeshVertices [] = { -20 , -4 , 0 , //0 0 , 20 , 20 , //1 20 , -4 , 0 , //2 0 , 20 , -20 //3 }; uint32_t cutMeshFaces [] = { 0 , 1 , 2 , //0 0 , 2 , 3 //1 }; uint32_t cutMeshFaceSizes [] = { 3 , 3 }; uint32_t numCutMeshVertices = 4 ; uint32_t numCutMeshFaces = 2 ; Again, the data structures for defining our cut mesh are exactly the same as the source mesh. All we did was just change the data - simple.","title":"The cut mesh"},{"location":"tutorials/helloWorld/#visualising-mesh-placement","text":"Before we proceed onto actually calling any MCUT functions, here is a visual depiction of the relative placement of the two meshes: A combined visualisation of our meshes, using their unmodified vertex coordinates. This relative positioning is determined by our vertex coordinates - as specified when we defined the meshes.","title":"Visualising mesh placement"},{"location":"tutorials/helloWorld/#using-the-mcut-api","text":"Up to now, we have described how to define meshes in a suitable format for MCUT to read. This is the first step of using MCUT - actually defining the mesh data to use for cutting. In this section, we will now describe how to cut our cube mesh with the cut mesh using MCUT.","title":"Using the MCUT API"},{"location":"tutorials/helloWorld/#creating-a-context","text":"First things first, we must create a context. MCUT contexts are represented by McContext data structures, and you can create them using: McContext context = MC_NULL_HANDLE ; mcCreateContext ( & context , MC_NULL_HANDLE ); MCUT uses the allocated context object to handle state, memory resources, etc. We can also think of mcCreateContext like the \u2018init\u2019 function (kinda\u2026). And thats pretty much it - thats all we need to do in order to \u201cinitialize\u201d MCUT before we can do the fun stuff . Lets do some cutting.","title":"Creating a context"},{"location":"tutorials/helloWorld/#the-dispatch-call","text":"Now that we have our mesh data and a context has been created, the next step is cut the cube. To do this, we call the mcDispatch function like this: mcDispatch ( context , MC_DISPATCH_VERTEX_ARRAY_FLOAT , cubeVertices , cubeFaces , cubeFaceSizes , numCubeVertices , numCubeFaces , cutMeshVertices , cutMeshFaces , cutMeshFaceSizes , numCutMeshVertices , numCutMeshFaces ); \u2026 and that\u2019s it - we have cut our cube. Simple huh..? Before moving on to the next section, let peek at the parameters a bit. They seem a lot at-first-glance but if we look closer we can see that most of them are just our mesh variables that we defined previously. So they are covered. The first parameter is our context (of-course!) which will hold all information/state relating to our operation. The second parameter specifies how MCUT should interpret our vertex arrays ( cubeVertices and cutMeshVertices ). In this example, MC_DISPATCH_VERTEX_ARRAY_FLOAT means \u201cinterpret the data as 32-bit floats\u201d which must match with our arrays.","title":"The dispatch call"},{"location":"tutorials/helloWorld/#wheres-my-output","text":"At this point, MCUT has cut the cube, which was done by calling using the mcDispatch function. However, there\u2019s no evidence of output meshes anywhere in our code which we need to show that MCUT actually did something! So in this section, we will find out how to ask MCUT to give us the result(s) of the cutting operation that we just performed.","title":"Where's my output?"},{"location":"tutorials/helloWorld/#how-many-meshes","text":"The first step to getting our output from MCUT to query for how many meshes (otherwise known as \u201cconnected components\u201d) of a particular type are available. Since we are learning about what MCUT can do, we will request all of the output that resulted from our cube being cut. Here\u2019s how we do that: uint32_t numConnComps ; std :: vector < McConnectedComponent > connComps ; mcGetConnectedComponents ( context , MC_CONNECTED_COMPONENT_TYPE_ALL , 0 , NULL , & numConnComps ); connComps . resize ( numConnComps ); mcGetConnectedComponents ( context , MC_CONNECTED_COMPONENT_TYPE_ALL , ( uint32_t ) connComps . size (), connComps . data (), NULL ); Notice how we had to call mcGetConnectedComponents twice? We do this because in MCUT querying information is a two-step process. First you need to allocate memory for one or more structures. Then you need to initialize these structures. The code above calls mcGetConnectedComponents twice. The first time, it places the number of connected components in the numConnComps variable. The second time, it places McConnectedComponent structures in the connComps array. We\u2019ll employ this function-allocation-function procedure for many other types of queries as well. Notice that we also provided the parameter MC_CONNECTED_COMPONENT_TYPE_ALL which specifies that we want all connected components from MCUT. This allows for filtering to get just the connected components we want by specifying different values.","title":"How many meshes?"},{"location":"tutorials/helloWorld/#accessing-mesh-data","text":"Once we\u2019ve accessed an available connected component, we can access every type of data that we can query for one - like its vertices. In code, connected components (i.e. meshes) are represented by McConnectedComponent structures. These are easy to work with, and the functions that relate to connected component data are very similar to mcGetConnectedComponents from the preceding section. This section presents the another MCUT connected component function, mcGetConnectedComponentData , and shows how it is used in code. As its name implies, mcGetConnectedComponentData accepts a McConnectedComponent (amongst others) and provides information about the corresponding connected component. This operates in exactly the same way that mcGetConnectedComponents does: Identify the type of information you\u2019re looking for, and the function will place the data in the memory referenced. We will now show how to query connected componented data. Assume that these variables have been defined in the following snippets: McConnectedComponent connComp = connComps [ i ]; // connected component handle. uint64_t numBytes = 0 ; // number of bytes we must allocate. And here is how we query the data of a connected component (vertices, faces etc.): query the vertices mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_VERTEX_FLOAT , 0 , NULL , & numBytes ); std :: vector < float > vertices ; vertices . resize ( numBytes / sizeof ( float )); //... or --> numberOfVertices * 3 mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_VERTEX_FLOAT , numBytes , ( void * ) vertices . data (), NULL ); The number of vertices can be determined based on the type used to represent the queried vertices and the number of bytes: uint32_t numberOfVertices = numBytes / ( sizeof ( float ) * 3 ); // 3 floats per vertex query the faces mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE , 0 , NULL , & numBytes ); std :: vector < uint32_t > faceIndices ; faceIndices . resize ( numBytes / sizeof ( uint32_t )); mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE , numBytes , faceIndices . data (), NULL ); query the face sizes mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE_SIZE , 0 , NULL , & numBytes ); std :: vector < uint32_t > faceSizes ; faceSizes . resize ( numBytes / sizeof ( uint32_t )); mcGetConnectedComponentData ( context , connComp , MC_CONNECTED_COMPONENT_DATA_FACE_SIZE , numBytes , faceSizes . data (), NULL ); Glancing through the code, its fairly easy to see that we are using mcGetConnectedComponentData similarly to the way we used mcGetConnectedComponents in the previous section, which makes the library very easy to use. We are done! So lets clean up before seeing our results and wrapping up below.","title":"Accessing mesh data"},{"location":"tutorials/helloWorld/#cleaning-up","text":"Now that we have finished using MCUT, we must free all resources that were allocated for our connected components. Since we want to free all connected component data, we will just do: mcReleaseConnectedComponents ( context , 0 , NULL ); \u2026 which will release the resources held by the library for all connected components. Finally, we will also destroy our context since we will not be performing any further cutting operations. Here\u2019s how we do that: mcReleaseContext ( context );","title":"Cleaning up"},{"location":"tutorials/helloWorld/#results","text":"In this section, we show the meshes produced as a result of cutting our cube with MCUT. Internally sealed fragments Here we show the canonical results of the cut, which are the two watertight fragments of our cube. We have effectively cut and filled the holes in our cube to produce the fragments. Internally-sealed lower fragment. Internally-sealed upper fragment. Externally sealed fragments Here we show an odd but unique case, which is an example of sealing our cube from the outside. Externally-sealed lower fragment. Externally-sealed upper fragment. Such a result is readily produced by MCUT, and is the cornerstone of MCUT\u2019s support of CSG (boolean) operations. As you may imagine, this feature enables new techniques and effects for mesh editing tools. Unsealed fragments In this example, we show that not only can MCUT produce watertight and externally sealed meshes, but that MCUT can also provide the unsealed fragments of the source mesh. It is also possible to retrieve partially sealed meshes which is not shown here. Unsealed lower fragment. Unsealed upper fragment. Patches While the focus is generally on the source much, the versatility MCUT also allows us to create cut-outs of the cut mesh. Interior patch. Exterior patch. We refer to this as stencilling . The left image show the interior patch of the cut surface, which can be used for emulating effects like \u201cgingerbread man\u201d style cut-outs. On the right, we show the exterior patch which likewise holds potential use-cases of its own. One example application, is producing silhouette cut-outs for simulating deformation or cloth-like effects on intricate geometries. Seams Finally, in this example we show that MCUT can also be used as a practical tool for computing intersection contours. These are the paths of intersection between the source mesh and cut mesh. Source mesh with added seam. Cut mesh with added seam. One example application of seams is global intersection analysis in character animation, which is the backbone of industry-standard collision-response algorithms for unoriented objects like cloth. A key point to note here is that this feature results directly from the generality of MCUT, resolving mesh intersections using the half-edge data structure.","title":"Results"},{"location":"tutorials/helloWorld/#summary","text":"In this tutorial, we have looked a simple HelloWorld-style of application using MCUT. First, mesh initialisation was described, showing that defining a mesh boils doing to simple C-style arrays. We then proceeded to create an MCUT context, which allowed us to submit a dispatch call to do the cutting. We demonstrated that all of these steps were brief and simple. Next, we delved into the task of querying data from MCUT after a dispatch call. In this regard, we found out how MCUT uses a \u201cfunction-allocation-function procedure\u201d to query information. This was then used to access connected components (our meshes), and their data (vertices, face indices etc.). Finally, we finished off by showing how to free internal memory allocated by the MCUT library, and then topped off with some nice visualisations of the output meshes.","title":"Summary"},{"location":"tutorials/meshes/","text":"This tutorial walks through the basics of MCUT, showing how to define a mesh and iterate through its vertices and faces. A mesh represents a two-manifold surface, where each edge is incident to one or two faces. An example of a 2-manifold mesh. Meshes in MCUT are represented as simple arrays of builtin C/C++ data types. In particular, users are permitted to use three C/C++ types when specifying vertex coordinates. These are float and double . 32-bit float vertex arrays \u00b6 The following is an example of how to define a mesh using the float data type to represent vertex positions: float pMeshVertices [] = { // xyz|xyz|x... -10.f , -5.f , 0.f , // vertex 0 -10.f , 5.f , 0.f , // vertex 1 10.f , 5.f , 0.f , 10.f , -5.f , 0.f , 5.f , 0.f , 0.f , 0.f , -5.f , 0.f , -5.f , 0.f , 0.f , -10.f , -10.f , 0.f , 10.f , -10.f , 0.f , 15.f , 5.f , 0.f , 15.f , -10.f , 0.f }; uint32_t pMeshFaceIndices [] = { 0 , 6 , 5 , 4 , 3 , 2 , 1 , // face 0 0 , 7 , 8 , 3 , 4 , 5 , 6 , // face 1 8 , 10 , 9 , 2 , 3 // face 2 }; McFaceSize pMeshFaceSizes [] = { 7 , 7 , 5 }; uint32_t numMeshVertices = 11 ; uint32_t numMeshFaces = 3 ; 64-bit double vertex arrays \u00b6 Using the same mesh example, the following except shows how to specify vertices as an array of double : double pMeshVertices [] = { -10.0 , -5.0 , 0.0 , -10.0 , 5.0 , 0.0 , 10.0 , 5.0 , 0.0 , 10.0 , -5.0 , 0.0 , 5.0 , 0.0 , 0.0 , 0.0 , -5.0 , 0.0 , -5.0 , 0.0 , 0.0 , -10.0 , -10.0 , 0.0 , 10.0 , -10.0 , 0.0 , 15.0 , 5.0 , 0.0 , 15.0 , -10.0 , 0.0 }; Accessing mesh elements \u00b6 As a simple demonstration of the mesh data structure defined above, let us iterate through the vertices and faces of the mesh. // vertices for ( uint32_t i = 0 ; i < numMeshVertices ; ++ i ) { // assuming float float x = pMeshVertices [ i * 3 + 0 ]; float y = pMeshVertices [ i * 3 + 1 ]; float z = pMeshVertices [ i * 3 + 2 ]; printf ( \"vertex: %f %f %f \\n \" , x , y , z ); } // faces uint32_t base = 0 ; for ( int i = 0 ; i < numMeshFaces ; ++ i ){ uint32_t numFaceVertices = pMeshFaceSizes [ i ]; printf ( \"face %d (%hu vertices):\" , i , numFaceVertices ); for ( uint32_t j = 0 ; j < numFaceVertices ; ++ j ) { printf ( \" %u\" , pMeshFaceIndices [ base + j ]); } printf ( \" \\n \" ); base += numFaceVertices ; }","title":"Meshes"},{"location":"tutorials/meshes/#32-bit-float-vertex-arrays","text":"The following is an example of how to define a mesh using the float data type to represent vertex positions: float pMeshVertices [] = { // xyz|xyz|x... -10.f , -5.f , 0.f , // vertex 0 -10.f , 5.f , 0.f , // vertex 1 10.f , 5.f , 0.f , 10.f , -5.f , 0.f , 5.f , 0.f , 0.f , 0.f , -5.f , 0.f , -5.f , 0.f , 0.f , -10.f , -10.f , 0.f , 10.f , -10.f , 0.f , 15.f , 5.f , 0.f , 15.f , -10.f , 0.f }; uint32_t pMeshFaceIndices [] = { 0 , 6 , 5 , 4 , 3 , 2 , 1 , // face 0 0 , 7 , 8 , 3 , 4 , 5 , 6 , // face 1 8 , 10 , 9 , 2 , 3 // face 2 }; McFaceSize pMeshFaceSizes [] = { 7 , 7 , 5 }; uint32_t numMeshVertices = 11 ; uint32_t numMeshFaces = 3 ;","title":"32-bit float vertex arrays"},{"location":"tutorials/meshes/#64-bit-double-vertex-arrays","text":"Using the same mesh example, the following except shows how to specify vertices as an array of double : double pMeshVertices [] = { -10.0 , -5.0 , 0.0 , -10.0 , 5.0 , 0.0 , 10.0 , 5.0 , 0.0 , 10.0 , -5.0 , 0.0 , 5.0 , 0.0 , 0.0 , 0.0 , -5.0 , 0.0 , -5.0 , 0.0 , 0.0 , -10.0 , -10.0 , 0.0 , 10.0 , -10.0 , 0.0 , 15.0 , 5.0 , 0.0 , 15.0 , -10.0 , 0.0 };","title":"64-bit double vertex arrays"},{"location":"tutorials/meshes/#accessing-mesh-elements","text":"As a simple demonstration of the mesh data structure defined above, let us iterate through the vertices and faces of the mesh. // vertices for ( uint32_t i = 0 ; i < numMeshVertices ; ++ i ) { // assuming float float x = pMeshVertices [ i * 3 + 0 ]; float y = pMeshVertices [ i * 3 + 1 ]; float z = pMeshVertices [ i * 3 + 2 ]; printf ( \"vertex: %f %f %f \\n \" , x , y , z ); } // faces uint32_t base = 0 ; for ( int i = 0 ; i < numMeshFaces ; ++ i ){ uint32_t numFaceVertices = pMeshFaceSizes [ i ]; printf ( \"face %d (%hu vertices):\" , i , numFaceVertices ); for ( uint32_t j = 0 ; j < numFaceVertices ; ++ j ) { printf ( \" %u\" , pMeshFaceIndices [ base + j ]); } printf ( \" \\n \" ); base += numFaceVertices ; }","title":"Accessing mesh elements"}]}